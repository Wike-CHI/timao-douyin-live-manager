# 提猫直播助手 - 安全加固实施指南

## 🎯 目标概述

本指南旨在解决代码审查中发现的安全风险，提供具体的修复方案和实施步骤。

---

## 🚨 高风险问题修复

### 1. CORS配置加固

#### 当前问题
```python
# start_web_server.py - 过于宽松的CORS配置
self.send_header('Access-Control-Allow-Origin', '*')
```

#### 修复方案
```python
# server/middleware/cors.py (新建文件)
from fastapi.middleware.cors import CORSMiddleware
from server.config import get_settings

def setup_cors(app):
    settings = get_settings()
    
    # 生产环境严格配置
    if settings.environment == "production":
        allowed_origins = [
            "https://yourdomain.com",
            "https://www.yourdomain.com"
        ]
    else:
        # 开发环境相对宽松
        allowed_origins = [
            "http://localhost:3000",
            "http://localhost:8080",
            "http://127.0.0.1:3000"
        ]
    
    app.add_middleware(
        CORSMiddleware,
        allow_origins=allowed_origins,
        allow_credentials=True,
        allow_methods=["GET", "POST", "PUT", "DELETE"],
        allow_headers=["Authorization", "Content-Type"],
        max_age=3600,  # 预检请求缓存时间
    )
```

#### 配置更新
```python
# server/config.py - 添加CORS配置
class SecurityConfig(BaseModel):
    cors_origins: List[str] = Field(
        default=["http://localhost:3000"],
        description="允许的CORS源"
    )
    cors_credentials: bool = Field(
        default=True,
        description="是否允许携带凭证"
    )
```

### 2. 请求频率限制

#### 实施方案
```python
# server/middleware/rate_limit.py (新建文件)
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded
from fastapi import Request, HTTPException

# 创建限流器
limiter = Limiter(
    key_func=get_remote_address,
    default_limits=["100/hour"]  # 默认限制
)

def setup_rate_limiting(app):
    app.state.limiter = limiter
    app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# 使用示例
from server.middleware.rate_limit import limiter

@app.post("/api/comments")
@limiter.limit("10/minute")  # 每分钟最多10次
async def create_comment(request: Request, comment_data: dict):
    return await process_comment(comment_data)

@app.post("/api/login")
@limiter.limit("5/minute")  # 登录限制更严格
async def login(request: Request, credentials: dict):
    return await authenticate_user(credentials)
```

### 3. 输入验证增强

#### 当前验证器增强
```python
# server/utils/validators.py - 增强版本
import re
from typing import Any, Dict, List, Optional
from pydantic import BaseModel, validator, Field

class EnhancedCommentValidator(BaseModel):
    user: str = Field(..., min_length=1, max_length=50)
    content: str = Field(..., min_length=1, max_length=1000)
    timestamp: Optional[int] = None
    
    @validator('user')
    def validate_user(cls, v):
        # 防止XSS
        if re.search(r'[<>"\']', v):
            raise ValueError("用户名包含非法字符")
        return v.strip()
    
    @validator('content')
    def validate_content(cls, v):
        # 内容安全检查
        dangerous_patterns = [
            r'<script.*?>.*?</script>',
            r'javascript:',
            r'on\w+\s*=',
            r'<iframe.*?>',
        ]
        
        for pattern in dangerous_patterns:
            if re.search(pattern, v, re.IGNORECASE):
                raise ValueError("内容包含潜在危险代码")
        
        return v.strip()

# SQL注入防护
class DatabaseQueryValidator:
    @staticmethod
    def sanitize_sql_input(value: str) -> str:
        """清理SQL输入，防止注入"""
        if not isinstance(value, str):
            return str(value)
        
        # 移除危险字符
        dangerous_chars = ["'", '"', ";", "--", "/*", "*/", "xp_", "sp_"]
        for char in dangerous_chars:
            value = value.replace(char, "")
        
        return value[:255]  # 限制长度
```

### 4. 安全头设置

#### 实施方案
```python
# server/middleware/security_headers.py (新建文件)
from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware

class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        response = await call_next(request)
        
        # 安全头设置
        security_headers = {
            "X-Content-Type-Options": "nosniff",
            "X-Frame-Options": "DENY",
            "X-XSS-Protection": "1; mode=block",
            "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
            "Content-Security-Policy": (
                "default-src 'self'; "
                "script-src 'self' 'unsafe-inline'; "
                "style-src 'self' 'unsafe-inline'; "
                "img-src 'self' data: https:; "
                "connect-src 'self'"
            ),
            "Referrer-Policy": "strict-origin-when-cross-origin",
            "Permissions-Policy": "geolocation=(), microphone=(), camera=()"
        }
        
        for header, value in security_headers.items():
            response.headers[header] = value
        
        return response

# 应用中间件
def setup_security_headers(app):
    app.add_middleware(SecurityHeadersMiddleware)
```

---

## 🔐 认证和授权

### JWT令牌实现
```python
# server/auth/jwt_handler.py (新建文件)
import jwt
from datetime import datetime, timedelta
from typing import Optional
from server.config import get_settings

class JWTHandler:
    def __init__(self):
        self.settings = get_settings()
        self.secret_key = self.settings.secret_key
        self.algorithm = "HS256"
        self.access_token_expire = timedelta(hours=1)
        self.refresh_token_expire = timedelta(days=7)
    
    def create_access_token(self, user_id: str) -> str:
        expire = datetime.utcnow() + self.access_token_expire
        payload = {
            "user_id": user_id,
            "exp": expire,
            "type": "access"
        }
        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
    
    def create_refresh_token(self, user_id: str) -> str:
        expire = datetime.utcnow() + self.refresh_token_expire
        payload = {
            "user_id": user_id,
            "exp": expire,
            "type": "refresh"
        }
        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
    
    def verify_token(self, token: str) -> Optional[dict]:
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            return payload
        except jwt.ExpiredSignatureError:
            return None
        except jwt.InvalidTokenError:
            return None

# 认证依赖
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer

security = HTTPBearer()
jwt_handler = JWTHandler()

async def get_current_user(token: str = Depends(security)):
    payload = jwt_handler.verify_token(token.credentials)
    if not payload:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="无效的认证令牌"
        )
    return payload["user_id"]
```

---

## 🛡️ 数据保护

### 敏感数据加密
```python
# server/utils/encryption.py (新建文件)
import hashlib
import secrets
from cryptography.fernet import Fernet
from server.config import get_settings

class DataEncryption:
    def __init__(self):
        self.settings = get_settings()
        self.cipher_suite = Fernet(self.settings.encryption_key.encode())
    
    def encrypt_sensitive_data(self, data: str) -> str:
        """加密敏感数据"""
        return self.cipher_suite.encrypt(data.encode()).decode()
    
    def decrypt_sensitive_data(self, encrypted_data: str) -> str:
        """解密敏感数据"""
        return self.cipher_suite.decrypt(encrypted_data.encode()).decode()
    
    @staticmethod
    def hash_password(password: str) -> tuple[str, str]:
        """密码哈希"""
        salt = secrets.token_hex(32)
        password_hash = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode('utf-8'),
            salt.encode('utf-8'),
            100000  # 迭代次数
        )
        return password_hash.hex(), salt
    
    @staticmethod
    def verify_password(password: str, hash_value: str, salt: str) -> bool:
        """验证密码"""
        password_hash = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode('utf-8'),
            salt.encode('utf-8'),
            100000
        )
        return password_hash.hex() == hash_value
```

---

## 📝 日志安全

### 安全日志配置
```python
# server/utils/secure_logger.py (新建文件)
import logging
import re
from typing import Any

class SecureFormatter(logging.Formatter):
    """安全日志格式化器，自动脱敏敏感信息"""
    
    SENSITIVE_PATTERNS = [
        (r'password["\']?\s*[:=]\s*["\']?([^"\'\\s]+)', 'password=***'),
        (r'token["\']?\s*[:=]\s*["\']?([^"\'\\s]+)', 'token=***'),
        (r'api_key["\']?\s*[:=]\s*["\']?([^"\'\\s]+)', 'api_key=***'),
        (r'secret["\']?\s*[:=]\s*["\']?([^"\'\\s]+)', 'secret=***'),
        (r'\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b', '****-****-****-****'),  # 信用卡号
        (r'\b\d{11}\b', '***********'),  # 手机号
    ]
    
    def format(self, record: logging.LogRecord) -> str:
        # 获取原始消息
        message = super().format(record)
        
        # 脱敏处理
        for pattern, replacement in self.SENSITIVE_PATTERNS:
            message = re.sub(pattern, replacement, message, flags=re.IGNORECASE)
        
        return message

def setup_secure_logging():
    """配置安全日志"""
    logger = logging.getLogger()
    
    # 移除现有处理器
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)
    
    # 控制台处理器
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(SecureFormatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    ))
    
    # 文件处理器
    file_handler = logging.FileHandler('logs/secure.log')
    file_handler.setFormatter(SecureFormatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s'
    ))
    
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)
    logger.setLevel(logging.INFO)
```

---

## 🔧 实施步骤

### 第1步: 环境准备
```bash
# 安装安全相关依赖
pip install slowapi cryptography pyjwt python-multipart

# 更新requirements.txt
echo "slowapi>=0.1.9" >> server/requirements.txt
echo "cryptography>=41.0.0" >> server/requirements.txt
echo "pyjwt>=2.8.0" >> server/requirements.txt
```

### 第2步: 配置更新
```python
# server/config.py - 添加安全配置
class SecurityConfig(BaseModel):
    secret_key: str = Field(..., description="JWT密钥")
    encryption_key: str = Field(..., description="数据加密密钥")
    cors_origins: List[str] = Field(default=["http://localhost:3000"])
    rate_limit_enabled: bool = Field(default=True)
    security_headers_enabled: bool = Field(default=True)
```

### 第3步: 中间件集成
```python
# server/main.py - 应用安全中间件
from server.middleware.cors import setup_cors
from server.middleware.rate_limit import setup_rate_limiting
from server.middleware.security_headers import setup_security_headers

def create_app():
    app = FastAPI(title="提猫直播助手")
    
    # 安全中间件
    setup_cors(app)
    setup_rate_limiting(app)
    setup_security_headers(app)
    
    return app
```

### 第4步: 测试验证
```python
# tests/test_security.py (新建文件)
import pytest
from fastapi.testclient import TestClient
from server.main import create_app

@pytest.fixture
def client():
    app = create_app()
    return TestClient(app)

def test_cors_headers(client):
    response = client.options("/api/comments")
    assert "Access-Control-Allow-Origin" in response.headers

def test_rate_limiting(client):
    # 测试频率限制
    for _ in range(15):  # 超过限制
        response = client.post("/api/comments", json={"test": "data"})
    
    assert response.status_code == 429  # Too Many Requests

def test_security_headers(client):
    response = client.get("/")
    assert response.headers.get("X-Content-Type-Options") == "nosniff"
    assert response.headers.get("X-Frame-Options") == "DENY"
```

---

## 📊 安全检查清单

### 实施前检查
- [ ] 备份当前代码
- [ ] 准备测试环境
- [ ] 确认依赖版本兼容性
- [ ] 准备回滚方案

### 实施后验证
- [ ] CORS配置测试
- [ ] 频率限制功能测试
- [ ] 安全头检查
- [ ] 输入验证测试
- [ ] 日志脱敏验证
- [ ] 性能影响评估

### 持续监控
- [ ] 安全日志监控
- [ ] 异常请求告警
- [ ] 性能指标跟踪
- [ ] 定期安全扫描

---

## 🚨 应急响应

### 安全事件处理流程
1. **立即响应**: 隔离受影响系统
2. **影响评估**: 确定数据泄露范围
3. **修复实施**: 应用紧急补丁
4. **通知相关方**: 按法规要求通知
5. **事后分析**: 改进安全措施

### 联系信息
- **安全负责人**: [待填写]
- **应急热线**: [待填写]
- **技术支持**: [待填写]

---

*本指南应定期更新，确保与最新安全威胁和最佳实践保持同步。*