# æçŒ«ç›´æ’­åŠ©æ‰‹ - å®‰å…¨åŠ å›ºå®æ–½æŒ‡å—

## ğŸ¯ ç›®æ ‡æ¦‚è¿°

æœ¬æŒ‡å—æ—¨åœ¨è§£å†³ä»£ç å®¡æŸ¥ä¸­å‘ç°çš„å®‰å…¨é£é™©ï¼Œæä¾›å…·ä½“çš„ä¿®å¤æ–¹æ¡ˆå’Œå®æ–½æ­¥éª¤ã€‚

---

## ğŸš¨ é«˜é£é™©é—®é¢˜ä¿®å¤

### 1. CORSé…ç½®åŠ å›º

#### å½“å‰é—®é¢˜
```python
# start_web_server.py - è¿‡äºå®½æ¾çš„CORSé…ç½®
self.send_header('Access-Control-Allow-Origin', '*')
```

#### ä¿®å¤æ–¹æ¡ˆ
```python
# server/middleware/cors.py (æ–°å»ºæ–‡ä»¶)
from fastapi.middleware.cors import CORSMiddleware
from server.config import get_settings

def setup_cors(app):
    settings = get_settings()
    
    # ç”Ÿäº§ç¯å¢ƒä¸¥æ ¼é…ç½®
    if settings.environment == "production":
        allowed_origins = [
            "https://yourdomain.com",
            "https://www.yourdomain.com"
        ]
    else:
        # å¼€å‘ç¯å¢ƒç›¸å¯¹å®½æ¾
        allowed_origins = [
            "http://localhost:3000",
            "http://localhost:8080",
            "http://127.0.0.1:3000"
        ]
    
    app.add_middleware(
        CORSMiddleware,
        allow_origins=allowed_origins,
        allow_credentials=True,
        allow_methods=["GET", "POST", "PUT", "DELETE"],
        allow_headers=["Authorization", "Content-Type"],
        max_age=3600,  # é¢„æ£€è¯·æ±‚ç¼“å­˜æ—¶é—´
    )
```

#### é…ç½®æ›´æ–°
```python
# server/config.py - æ·»åŠ CORSé…ç½®
class SecurityConfig(BaseModel):
    cors_origins: List[str] = Field(
        default=["http://localhost:3000"],
        description="å…è®¸çš„CORSæº"
    )
    cors_credentials: bool = Field(
        default=True,
        description="æ˜¯å¦å…è®¸æºå¸¦å‡­è¯"
    )
```

### 2. è¯·æ±‚é¢‘ç‡é™åˆ¶

#### å®æ–½æ–¹æ¡ˆ
```python
# server/middleware/rate_limit.py (æ–°å»ºæ–‡ä»¶)
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded
from fastapi import Request, HTTPException

# åˆ›å»ºé™æµå™¨
limiter = Limiter(
    key_func=get_remote_address,
    default_limits=["100/hour"]  # é»˜è®¤é™åˆ¶
)

def setup_rate_limiting(app):
    app.state.limiter = limiter
    app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# ä½¿ç”¨ç¤ºä¾‹
from server.middleware.rate_limit import limiter

@app.post("/api/comments")
@limiter.limit("10/minute")  # æ¯åˆ†é’Ÿæœ€å¤š10æ¬¡
async def create_comment(request: Request, comment_data: dict):
    return await process_comment(comment_data)

@app.post("/api/login")
@limiter.limit("5/minute")  # ç™»å½•é™åˆ¶æ›´ä¸¥æ ¼
async def login(request: Request, credentials: dict):
    return await authenticate_user(credentials)
```

### 3. è¾“å…¥éªŒè¯å¢å¼º

#### å½“å‰éªŒè¯å™¨å¢å¼º
```python
# server/utils/validators.py - å¢å¼ºç‰ˆæœ¬
import re
from typing import Any, Dict, List, Optional
from pydantic import BaseModel, validator, Field

class EnhancedCommentValidator(BaseModel):
    user: str = Field(..., min_length=1, max_length=50)
    content: str = Field(..., min_length=1, max_length=1000)
    timestamp: Optional[int] = None
    
    @validator('user')
    def validate_user(cls, v):
        # é˜²æ­¢XSS
        if re.search(r'[<>"\']', v):
            raise ValueError("ç”¨æˆ·ååŒ…å«éæ³•å­—ç¬¦")
        return v.strip()
    
    @validator('content')
    def validate_content(cls, v):
        # å†…å®¹å®‰å…¨æ£€æŸ¥
        dangerous_patterns = [
            r'<script.*?>.*?</script>',
            r'javascript:',
            r'on\w+\s*=',
            r'<iframe.*?>',
        ]
        
        for pattern in dangerous_patterns:
            if re.search(pattern, v, re.IGNORECASE):
                raise ValueError("å†…å®¹åŒ…å«æ½œåœ¨å±é™©ä»£ç ")
        
        return v.strip()

# SQLæ³¨å…¥é˜²æŠ¤
class DatabaseQueryValidator:
    @staticmethod
    def sanitize_sql_input(value: str) -> str:
        """æ¸…ç†SQLè¾“å…¥ï¼Œé˜²æ­¢æ³¨å…¥"""
        if not isinstance(value, str):
            return str(value)
        
        # ç§»é™¤å±é™©å­—ç¬¦
        dangerous_chars = ["'", '"', ";", "--", "/*", "*/", "xp_", "sp_"]
        for char in dangerous_chars:
            value = value.replace(char, "")
        
        return value[:255]  # é™åˆ¶é•¿åº¦
```

### 4. å®‰å…¨å¤´è®¾ç½®

#### å®æ–½æ–¹æ¡ˆ
```python
# server/middleware/security_headers.py (æ–°å»ºæ–‡ä»¶)
from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware

class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        response = await call_next(request)
        
        # å®‰å…¨å¤´è®¾ç½®
        security_headers = {
            "X-Content-Type-Options": "nosniff",
            "X-Frame-Options": "DENY",
            "X-XSS-Protection": "1; mode=block",
            "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
            "Content-Security-Policy": (
                "default-src 'self'; "
                "script-src 'self' 'unsafe-inline'; "
                "style-src 'self' 'unsafe-inline'; "
                "img-src 'self' data: https:; "
                "connect-src 'self'"
            ),
            "Referrer-Policy": "strict-origin-when-cross-origin",
            "Permissions-Policy": "geolocation=(), microphone=(), camera=()"
        }
        
        for header, value in security_headers.items():
            response.headers[header] = value
        
        return response

# åº”ç”¨ä¸­é—´ä»¶
def setup_security_headers(app):
    app.add_middleware(SecurityHeadersMiddleware)
```

---

## ğŸ” è®¤è¯å’Œæˆæƒ

### JWTä»¤ç‰Œå®ç°
```python
# server/auth/jwt_handler.py (æ–°å»ºæ–‡ä»¶)
import jwt
from datetime import datetime, timedelta
from typing import Optional
from server.config import get_settings

class JWTHandler:
    def __init__(self):
        self.settings = get_settings()
        self.secret_key = self.settings.secret_key
        self.algorithm = "HS256"
        self.access_token_expire = timedelta(hours=1)
        self.refresh_token_expire = timedelta(days=7)
    
    def create_access_token(self, user_id: str) -> str:
        expire = datetime.utcnow() + self.access_token_expire
        payload = {
            "user_id": user_id,
            "exp": expire,
            "type": "access"
        }
        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
    
    def create_refresh_token(self, user_id: str) -> str:
        expire = datetime.utcnow() + self.refresh_token_expire
        payload = {
            "user_id": user_id,
            "exp": expire,
            "type": "refresh"
        }
        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
    
    def verify_token(self, token: str) -> Optional[dict]:
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            return payload
        except jwt.ExpiredSignatureError:
            return None
        except jwt.InvalidTokenError:
            return None

# è®¤è¯ä¾èµ–
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer

security = HTTPBearer()
jwt_handler = JWTHandler()

async def get_current_user(token: str = Depends(security)):
    payload = jwt_handler.verify_token(token.credentials)
    if not payload:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="æ— æ•ˆçš„è®¤è¯ä»¤ç‰Œ"
        )
    return payload["user_id"]
```

---

## ğŸ›¡ï¸ æ•°æ®ä¿æŠ¤

### æ•æ„Ÿæ•°æ®åŠ å¯†
```python
# server/utils/encryption.py (æ–°å»ºæ–‡ä»¶)
import hashlib
import secrets
from cryptography.fernet import Fernet
from server.config import get_settings

class DataEncryption:
    def __init__(self):
        self.settings = get_settings()
        self.cipher_suite = Fernet(self.settings.encryption_key.encode())
    
    def encrypt_sensitive_data(self, data: str) -> str:
        """åŠ å¯†æ•æ„Ÿæ•°æ®"""
        return self.cipher_suite.encrypt(data.encode()).decode()
    
    def decrypt_sensitive_data(self, encrypted_data: str) -> str:
        """è§£å¯†æ•æ„Ÿæ•°æ®"""
        return self.cipher_suite.decrypt(encrypted_data.encode()).decode()
    
    @staticmethod
    def hash_password(password: str) -> tuple[str, str]:
        """å¯†ç å“ˆå¸Œ"""
        salt = secrets.token_hex(32)
        password_hash = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode('utf-8'),
            salt.encode('utf-8'),
            100000  # è¿­ä»£æ¬¡æ•°
        )
        return password_hash.hex(), salt
    
    @staticmethod
    def verify_password(password: str, hash_value: str, salt: str) -> bool:
        """éªŒè¯å¯†ç """
        password_hash = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode('utf-8'),
            salt.encode('utf-8'),
            100000
        )
        return password_hash.hex() == hash_value
```

---

## ğŸ“ æ—¥å¿—å®‰å…¨

### å®‰å…¨æ—¥å¿—é…ç½®
```python
# server/utils/secure_logger.py (æ–°å»ºæ–‡ä»¶)
import logging
import re
from typing import Any

class SecureFormatter(logging.Formatter):
    """å®‰å…¨æ—¥å¿—æ ¼å¼åŒ–å™¨ï¼Œè‡ªåŠ¨è„±æ•æ•æ„Ÿä¿¡æ¯"""
    
    SENSITIVE_PATTERNS = [
        (r'password["\']?\s*[:=]\s*["\']?([^"\'\\s]+)', 'password=***'),
        (r'token["\']?\s*[:=]\s*["\']?([^"\'\\s]+)', 'token=***'),
        (r'api_key["\']?\s*[:=]\s*["\']?([^"\'\\s]+)', 'api_key=***'),
        (r'secret["\']?\s*[:=]\s*["\']?([^"\'\\s]+)', 'secret=***'),
        (r'\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b', '****-****-****-****'),  # ä¿¡ç”¨å¡å·
        (r'\b\d{11}\b', '***********'),  # æ‰‹æœºå·
    ]
    
    def format(self, record: logging.LogRecord) -> str:
        # è·å–åŸå§‹æ¶ˆæ¯
        message = super().format(record)
        
        # è„±æ•å¤„ç†
        for pattern, replacement in self.SENSITIVE_PATTERNS:
            message = re.sub(pattern, replacement, message, flags=re.IGNORECASE)
        
        return message

def setup_secure_logging():
    """é…ç½®å®‰å…¨æ—¥å¿—"""
    logger = logging.getLogger()
    
    # ç§»é™¤ç°æœ‰å¤„ç†å™¨
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)
    
    # æ§åˆ¶å°å¤„ç†å™¨
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(SecureFormatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    ))
    
    # æ–‡ä»¶å¤„ç†å™¨
    file_handler = logging.FileHandler('logs/secure.log')
    file_handler.setFormatter(SecureFormatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s'
    ))
    
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)
    logger.setLevel(logging.INFO)
```

---

## ğŸ”§ å®æ–½æ­¥éª¤

### ç¬¬1æ­¥: ç¯å¢ƒå‡†å¤‡
```bash
# å®‰è£…å®‰å…¨ç›¸å…³ä¾èµ–
pip install slowapi cryptography pyjwt python-multipart

# æ›´æ–°requirements.txt
echo "slowapi>=0.1.9" >> server/requirements.txt
echo "cryptography>=41.0.0" >> server/requirements.txt
echo "pyjwt>=2.8.0" >> server/requirements.txt
```

### ç¬¬2æ­¥: é…ç½®æ›´æ–°
```python
# server/config.py - æ·»åŠ å®‰å…¨é…ç½®
class SecurityConfig(BaseModel):
    secret_key: str = Field(..., description="JWTå¯†é’¥")
    encryption_key: str = Field(..., description="æ•°æ®åŠ å¯†å¯†é’¥")
    cors_origins: List[str] = Field(default=["http://localhost:3000"])
    rate_limit_enabled: bool = Field(default=True)
    security_headers_enabled: bool = Field(default=True)
```

### ç¬¬3æ­¥: ä¸­é—´ä»¶é›†æˆ
```python
# server/main.py - åº”ç”¨å®‰å…¨ä¸­é—´ä»¶
from server.middleware.cors import setup_cors
from server.middleware.rate_limit import setup_rate_limiting
from server.middleware.security_headers import setup_security_headers

def create_app():
    app = FastAPI(title="æçŒ«ç›´æ’­åŠ©æ‰‹")
    
    # å®‰å…¨ä¸­é—´ä»¶
    setup_cors(app)
    setup_rate_limiting(app)
    setup_security_headers(app)
    
    return app
```

### ç¬¬4æ­¥: æµ‹è¯•éªŒè¯
```python
# tests/test_security.py (æ–°å»ºæ–‡ä»¶)
import pytest
from fastapi.testclient import TestClient
from server.main import create_app

@pytest.fixture
def client():
    app = create_app()
    return TestClient(app)

def test_cors_headers(client):
    response = client.options("/api/comments")
    assert "Access-Control-Allow-Origin" in response.headers

def test_rate_limiting(client):
    # æµ‹è¯•é¢‘ç‡é™åˆ¶
    for _ in range(15):  # è¶…è¿‡é™åˆ¶
        response = client.post("/api/comments", json={"test": "data"})
    
    assert response.status_code == 429  # Too Many Requests

def test_security_headers(client):
    response = client.get("/")
    assert response.headers.get("X-Content-Type-Options") == "nosniff"
    assert response.headers.get("X-Frame-Options") == "DENY"
```

---

## ğŸ“Š å®‰å…¨æ£€æŸ¥æ¸…å•

### å®æ–½å‰æ£€æŸ¥
- [ ] å¤‡ä»½å½“å‰ä»£ç 
- [ ] å‡†å¤‡æµ‹è¯•ç¯å¢ƒ
- [ ] ç¡®è®¤ä¾èµ–ç‰ˆæœ¬å…¼å®¹æ€§
- [ ] å‡†å¤‡å›æ»šæ–¹æ¡ˆ

### å®æ–½åéªŒè¯
- [ ] CORSé…ç½®æµ‹è¯•
- [ ] é¢‘ç‡é™åˆ¶åŠŸèƒ½æµ‹è¯•
- [ ] å®‰å…¨å¤´æ£€æŸ¥
- [ ] è¾“å…¥éªŒè¯æµ‹è¯•
- [ ] æ—¥å¿—è„±æ•éªŒè¯
- [ ] æ€§èƒ½å½±å“è¯„ä¼°

### æŒç»­ç›‘æ§
- [ ] å®‰å…¨æ—¥å¿—ç›‘æ§
- [ ] å¼‚å¸¸è¯·æ±‚å‘Šè­¦
- [ ] æ€§èƒ½æŒ‡æ ‡è·Ÿè¸ª
- [ ] å®šæœŸå®‰å…¨æ‰«æ

---

## ğŸš¨ åº”æ€¥å“åº”

### å®‰å…¨äº‹ä»¶å¤„ç†æµç¨‹
1. **ç«‹å³å“åº”**: éš”ç¦»å—å½±å“ç³»ç»Ÿ
2. **å½±å“è¯„ä¼°**: ç¡®å®šæ•°æ®æ³„éœ²èŒƒå›´
3. **ä¿®å¤å®æ–½**: åº”ç”¨ç´§æ€¥è¡¥ä¸
4. **é€šçŸ¥ç›¸å…³æ–¹**: æŒ‰æ³•è§„è¦æ±‚é€šçŸ¥
5. **äº‹ååˆ†æ**: æ”¹è¿›å®‰å…¨æªæ–½

### è”ç³»ä¿¡æ¯
- **å®‰å…¨è´Ÿè´£äºº**: [å¾…å¡«å†™]
- **åº”æ€¥çƒ­çº¿**: [å¾…å¡«å†™]
- **æŠ€æœ¯æ”¯æŒ**: [å¾…å¡«å†™]

---

*æœ¬æŒ‡å—åº”å®šæœŸæ›´æ–°ï¼Œç¡®ä¿ä¸æœ€æ–°å®‰å…¨å¨èƒå’Œæœ€ä½³å®è·µä¿æŒåŒæ­¥ã€‚*