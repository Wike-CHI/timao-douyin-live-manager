# 提猫直播助手 - 测试覆盖率提升计划

## 📊 现状分析

### 当前测试覆盖率: 7%
```
总体统计:
- 总代码行数: 4,310行
- 已测试行数: 299行
- 未测试行数: 4,011行

模块分布:
- AST_module: ~15% (部分功能测试)
- server模块: ~5% (主要是空文件)
- 前端代码: 0% (未包含在统计中)
```

### 测试现状问题
1. **异步函数测试失败**: pytest不支持原生异步测试
2. **单元测试缺失**: 仅有简单的集成测试
3. **边界条件未覆盖**: 缺少异常场景测试
4. **Mock使用不足**: 外部依赖未隔离

---

## 🎯 目标设定

### 阶段性目标
| 阶段 | 时间 | 覆盖率目标 | 重点模块 |
|------|------|-----------|----------|
| 第1阶段 | 1周 | 30% | 核心业务逻辑 |
| 第2阶段 | 2周 | 50% | API接口层 |
| 第3阶段 | 3周 | 70% | 数据处理层 |
| 第4阶段 | 4周 | 80% | 完整系统 |

### 质量标准
- **单元测试**: 覆盖所有公共方法
- **集成测试**: 覆盖主要业务流程
- **边界测试**: 覆盖异常和边界条件
- **性能测试**: 关键接口性能验证

---

## 🔧 技术准备

### 1. 测试环境配置

#### 安装测试依赖
```bash
# 安装pytest异步支持
pip install pytest-asyncio pytest-mock pytest-cov

# 安装HTTP测试客户端
pip install httpx

# 安装数据库测试支持
pip install pytest-postgresql

# 更新requirements-test.txt
cat > requirements-test.txt << EOF
pytest>=7.4.0
pytest-asyncio>=0.21.0
pytest-mock>=3.11.0
pytest-cov>=4.1.0
httpx>=0.24.0
pytest-postgresql>=5.0.0
factory-boy>=3.3.0
faker>=19.0.0
EOF
```

#### pytest配置文件
```ini
# pytest.ini
[tool:pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    --strict-markers
    --strict-config
    --cov=server
    --cov=AST_module
    --cov-report=term-missing
    --cov-report=html:htmlcov
    --cov-report=xml
    --cov-fail-under=80
asyncio_mode = auto
markers =
    unit: 单元测试
    integration: 集成测试
    slow: 慢速测试
    external: 需要外部依赖的测试
```

### 2. 测试结构设计

#### 目录结构
```
tests/
├── conftest.py              # 全局配置和fixture
├── unit/                    # 单元测试
│   ├── test_validators.py
│   ├── test_config.py
│   ├── test_helpers.py
│   └── test_models.py
├── integration/             # 集成测试
│   ├── test_api_endpoints.py
│   ├── test_websocket.py
│   └── test_database.py
├── fixtures/                # 测试数据
│   ├── sample_comments.json
│   └── test_config.yaml
└── test_helpers/              # 测试辅助工具
    ├── ai_service_helper.py
    └── database_helper.py
```

---

## 📝 测试实施计划

### 第1阶段: 核心业务逻辑测试 (目标30%)

#### 1.1 数据验证器测试
```python
# tests/unit/test_validators.py
import pytest
from server.utils.validators import (
    CommentValidator, 
    ValidationError,
    sanitize_input
)

class TestCommentValidator:
    def test_valid_comment(self):
        """测试有效评论验证"""
        validator = CommentValidator()
        data = {
            "user": "测试用户",
            "content": "这是一条测试评论",
            "timestamp": 1640995200
        }
        result = validator.validate(data)
        assert result["user"] == "测试用户"
        assert result["content"] == "这是一条测试评论"
    
    def test_empty_user_raises_error(self):
        """测试空用户名抛出异常"""
        validator = CommentValidator()
        with pytest.raises(ValidationError, match="用户名不能为空"):
            validator.validate({"user": "", "content": "test"})
    
    def test_long_content_truncated(self):
        """测试长内容被截断"""
        validator = CommentValidator()
        long_content = "x" * 1001
        data = {"user": "test", "content": long_content}
        result = validator.validate(data)
        assert len(result["content"]) <= 1000
    
    @pytest.mark.parametrize("malicious_input,expected", [
        ("<script>alert('xss')</script>", "alert('xss')"),
        ("javascript:void(0)", "void(0)"),
        ("<img src=x onerror=alert(1)>", ""),
    ])
    def test_xss_protection(self, malicious_input, expected):
        """测试XSS防护"""
        result = sanitize_input(malicious_input)
        assert expected in result or result == ""
```

#### 1.2 配置管理测试
```python
# tests/unit/test_config.py
import pytest
import os
from unittest.mock import patch
from server.config import ServerConfig, DatabaseConfig, get_settings

class TestServerConfig:
    def test_default_config(self):
        """测试默认配置"""
        config = ServerConfig()
        assert config.host == "0.0.0.0"
        assert config.port == 10090
        assert config.debug is False
    
    @patch.dict(os.environ, {"HOST": "127.0.0.1", "PORT": "9000"})
    def test_env_override(self):
        """测试环境变量覆盖"""
        config = ServerConfig()
        assert config.host == "127.0.0.1"
        assert config.port == 9000
    
    def test_database_config_validation(self):
        """测试数据库配置验证"""
        with pytest.raises(ValueError):
            DatabaseConfig(host="", port=0)

class TestSettingsFactory:
    def test_get_settings_singleton(self):
        """测试设置单例模式"""
        settings1 = get_settings()
        settings2 = get_settings()
        assert settings1 is settings2
```

#### 1.3 工具函数测试
```python
# tests/unit/test_helpers.py
import pytest
from datetime import datetime
from server.utils.helpers import (
    format_timestamp,
    generate_cache_key,
    safe_json_loads
)

class TestHelperFunctions:
    def test_format_timestamp(self):
        """测试时间戳格式化"""
        timestamp = 1640995200  # 2022-01-01 00:00:00 UTC
        result = format_timestamp(timestamp)
        assert "2022-01-01" in result
    
    def test_generate_cache_key(self):
        """测试缓存键生成"""
        key = generate_cache_key("user", "123", "comments")
        assert key == "user:123:comments"
        
        # 测试特殊字符处理
        key = generate_cache_key("user:name", "test@email.com")
        assert ":" not in key.split(":")[1]  # 特殊字符被处理
    
    @pytest.mark.parametrize("json_str,expected", [
        ('{"key": "value"}', {"key": "value"}),
        ('invalid json', None),
        ('null', None),
        ('[]', []),
    ])
    def test_safe_json_loads(self, json_str, expected):
        """测试安全JSON解析"""
        result = safe_json_loads(json_str)
        assert result == expected
```

### 第2阶段: API接口测试 (目标50%)

#### 2.1 FastAPI端点测试
```python
# tests/integration/test_api_endpoints.py
import pytest
from httpx import AsyncClient
from server.main import app

@pytest.mark.asyncio
class TestCommentAPI:
    async def test_create_comment_success(self):
        """测试创建评论成功"""
        async with AsyncClient(app=app, base_url="http://test") as ac:
            response = await ac.post("/api/comments", json={
                "user": "测试用户",
                "content": "测试评论内容"
            })
        assert response.status_code == 201
        data = response.json()
        assert data["user"] == "测试用户"
        assert "id" in data
    
    async def test_create_comment_validation_error(self):
        """测试创建评论验证错误"""
        async with AsyncClient(app=app, base_url="http://test") as ac:
            response = await ac.post("/api/comments", json={
                "user": "",  # 空用户名
                "content": "测试内容"
            })
        assert response.status_code == 422
        assert "用户名不能为空" in response.text
    
    async def test_get_comments_pagination(self):
        """测试评论分页查询"""
        async with AsyncClient(app=app, base_url="http://test") as ac:
            response = await ac.get("/api/comments?page=1&size=10")
        assert response.status_code == 200
        data = response.json()
        assert "items" in data
        assert "total" in data
        assert "page" in data
    
    async def test_rate_limiting(self):
        """测试频率限制"""
        async with AsyncClient(app=app, base_url="http://test") as ac:
            # 快速发送多个请求
            for i in range(15):
                response = await ac.post("/api/comments", json={
                    "user": f"user{i}",
                    "content": f"content{i}"
                })
                if i < 10:
                    assert response.status_code in [201, 422]
                else:
                    # 超过限制后应该返回429
                    assert response.status_code == 429
```

#### 2.2 WebSocket测试
```python
# tests/integration/test_websocket.py
import pytest
import asyncio
from fastapi.testclient import TestClient
from server.main import app

@pytest.mark.asyncio
class TestWebSocketConnection:
    def test_websocket_connection(self):
        """测试WebSocket连接"""
        client = TestClient(app)
        with client.websocket_connect("/ws") as websocket:
            # 发送测试消息
            websocket.send_json({"type": "ping"})
            data = websocket.receive_json()
            assert data["type"] == "pong"
    
    def test_websocket_comment_broadcast(self):
        """测试评论广播"""
        client = TestClient(app)
        with client.websocket_connect("/ws") as websocket:
            # 模拟新评论
            test_comment = {
                "user": "测试用户",
                "content": "测试评论",
                "timestamp": 1640995200
            }
            
            # 这里需要触发评论创建事件
            # 然后验证WebSocket收到广播
            data = websocket.receive_json()
            assert data["type"] == "new_comment"
            assert data["data"]["user"] == "测试用户"
```

### 第3阶段: 数据处理层测试 (目标70%)

#### 3.1 AI服务测试
```python
# tests/unit/test_ai_services.py
import pytest
from unittest.mock import AsyncMock, patch
from server.ai.generator import CommentGenerator
from server.ai.tip_generator import TipGenerator

@pytest.mark.asyncio
class TestCommentGenerator:
    @patch('server.ai.generator.openai_client')
    async def test_generate_comment_success(self, mock_client):
        """测试评论生成成功"""
        # Mock OpenAI响应
        mock_client.chat.completions.create.return_value = AsyncMock()
        mock_client.chat.completions.create.return_value.choices = [
            AsyncMock(message=AsyncMock(content="生成的评论内容"))
        ]
        
        generator = CommentGenerator()
        result = await generator.generate_comment("直播主题")
        
        assert result == "生成的评论内容"
        mock_client.chat.completions.create.assert_called_once()
    
    @patch('server.ai.generator.openai_client')
    async def test_generate_comment_api_error(self, mock_client):
        """测试API错误处理"""
        mock_client.chat.completions.create.side_effect = Exception("API错误")
        
        generator = CommentGenerator()
        with pytest.raises(Exception, match="API错误"):
            await generator.generate_comment("直播主题")
    
    async def test_generate_comment_empty_topic(self):
        """测试空主题处理"""
        generator = CommentGenerator()
        with pytest.raises(ValueError, match="主题不能为空"):
            await generator.generate_comment("")
```

#### 3.2 数据库操作测试
```python
# tests/integration/test_database.py
import pytest
from server.models import Comment, User
from server.database import get_db_session

@pytest.mark.asyncio
class TestDatabaseOperations:
    async def test_create_comment(self, db_session):
        """测试创建评论"""
        comment_data = {
            "user": "测试用户",
            "content": "测试评论内容",
            "timestamp": 1640995200
        }
        
        comment = Comment(**comment_data)
        db_session.add(comment)
        await db_session.commit()
        
        assert comment.id is not None
        assert comment.user == "测试用户"
    
    async def test_query_comments_by_user(self, db_session):
        """测试按用户查询评论"""
        # 创建测试数据
        comments = [
            Comment(user="user1", content="content1"),
            Comment(user="user1", content="content2"),
            Comment(user="user2", content="content3"),
        ]
        
        for comment in comments:
            db_session.add(comment)
        await db_session.commit()
        
        # 查询user1的评论
        user1_comments = await db_session.query(Comment).filter(
            Comment.user == "user1"
        ).all()
        
        assert len(user1_comments) == 2
        assert all(c.user == "user1" for c in user1_comments)
```

### 第4阶段: 完整系统测试 (目标80%)

#### 4.1 端到端测试
```python
# tests/e2e/test_complete_workflow.py
import pytest
from httpx import AsyncClient
from server.main import app

@pytest.mark.asyncio
class TestCompleteWorkflow:
    async def test_comment_lifecycle(self):
        """测试评论完整生命周期"""
        async with AsyncClient(app=app, base_url="http://test") as ac:
            # 1. 创建评论
            create_response = await ac.post("/api/comments", json={
                "user": "测试用户",
                "content": "测试评论内容"
            })
            assert create_response.status_code == 201
            comment_id = create_response.json()["id"]
            
            # 2. 查询评论
            get_response = await ac.get(f"/api/comments/{comment_id}")
            assert get_response.status_code == 200
            comment_data = get_response.json()
            assert comment_data["user"] == "测试用户"
            
            # 3. 更新评论
            update_response = await ac.put(f"/api/comments/{comment_id}", json={
                "content": "更新后的内容"
            })
            assert update_response.status_code == 200
            
            # 4. 删除评论
            delete_response = await ac.delete(f"/api/comments/{comment_id}")
            assert delete_response.status_code == 204
            
            # 5. 验证删除
            get_deleted_response = await ac.get(f"/api/comments/{comment_id}")
            assert get_deleted_response.status_code == 404
```

---

## 🧪 测试工具和框架

### 1. Fixture管理
```python
# tests/conftest.py
import pytest
import asyncio
from httpx import AsyncClient
from server.main import app
from server.database import get_db_session, create_test_database

@pytest.fixture(scope="session")
def event_loop():
    """创建事件循环"""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()

@pytest.fixture
async def db_session():
    """数据库会话fixture"""
    session = await create_test_database()
    yield session
    await session.close()

@pytest.fixture
async def client():
    """HTTP客户端fixture"""
    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac

@pytest.fixture
def sample_comment():
    """示例评论数据"""
    return {
        "user": "测试用户",
        "content": "这是一条测试评论",
        "timestamp": 1640995200
    }
```

### 2. 测试辅助工具
```python
# tests/test_helpers/ai_service_helper.py
from unittest.mock import AsyncMock

class AIServiceHelper:
    def __init__(self):
        self.generate_comment = AsyncMock(return_value="模拟生成的评论")
        self.analyze_sentiment = AsyncMock(return_value="positive")
        self.extract_keywords = AsyncMock(return_value=["关键词1", "关键词2"])

@pytest.fixture
def ai_service_helper():
    return AIServiceHelper()
```

### 3. 数据工厂
```python
# tests/factories.py
import factory
from server.models import Comment, User

class CommentFactory(factory.Factory):
    class Meta:
        model = Comment
    
    user = factory.Sequence(lambda n: f"user{n}")
    content = factory.Faker('text', max_nb_chars=200)
    timestamp = factory.Faker('unix_time')

class UserFactory(factory.Factory):
    class Meta:
        model = User
    
    username = factory.Sequence(lambda n: f"user{n}")
    email = factory.Faker('email')
```

---

## 📊 持续集成配置

### GitHub Actions配置
```yaml
# .github/workflows/test.yml
name: 测试和覆盖率检查

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v3
    
    - name: 设置Python环境
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: 安装依赖
      run: |
        pip install -r requirements.txt
        pip install -r requirements-test.txt
    
    - name: 运行测试
      run: |
        pytest --cov=server --cov=AST_module --cov-report=xml
    
    - name: 上传覆盖率报告
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        fail_ci_if_error: true
    
    - name: 检查覆盖率阈值
      run: |
        pytest --cov=server --cov=AST_module --cov-fail-under=80
```

---

## 📈 监控和报告

### 1. 覆盖率报告生成
```bash
# 生成HTML报告
pytest --cov=server --cov=AST_module --cov-report=html

# 生成XML报告（用于CI）
pytest --cov=server --cov=AST_module --cov-report=xml

# 生成详细的缺失行报告
pytest --cov=server --cov=AST_module --cov-report=term-missing
```

### 2. 测试报告模板
```python
# scripts/generate_test_report.py
import json
from datetime import datetime

def generate_test_report(coverage_data, test_results):
    """生成测试报告"""
    report = {
        "timestamp": datetime.now().isoformat(),
        "coverage": {
            "total": coverage_data.get("total", 0),
            "by_module": coverage_data.get("modules", {}),
            "target": 80
        },
        "tests": {
            "total": test_results.get("total", 0),
            "passed": test_results.get("passed", 0),
            "failed": test_results.get("failed", 0),
            "skipped": test_results.get("skipped", 0)
        },
        "recommendations": generate_recommendations(coverage_data)
    }
    
    with open("test_report.json", "w") as f:
        json.dump(report, f, indent=2, ensure_ascii=False)
    
    return report
```

---

## 🎯 成功标准

### 量化指标
- **总体覆盖率**: ≥80%
- **核心模块覆盖率**: ≥90%
- **测试通过率**: 100%
- **测试执行时间**: <5分钟

### 质量标准
- **边界条件覆盖**: 所有异常路径
- **Mock使用**: 外部依赖完全隔离
- **测试独立性**: 测试间无依赖
- **文档完整性**: 所有测试用例有清晰说明

---

## 📅 实施时间表

| 周次 | 主要任务 | 交付物 | 负责人 |
|------|----------|--------|--------|
| 第1周 | 环境搭建 + 核心逻辑测试 | 30%覆盖率 | 开发团队 |
| 第2周 | API接口测试 | 50%覆盖率 | 开发团队 |
| 第3周 | 数据处理层测试 | 70%覆盖率 | 开发团队 |
| 第4周 | 系统测试 + 优化 | 80%覆盖率 | 全团队 |

---

*本计划将根据实际执行情况进行调整，确保在提升覆盖率的同时保证测试质量。*
