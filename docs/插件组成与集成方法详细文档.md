# æçŒ«ç›´æ’­åŠ©æ‰‹ - æ’ä»¶ç»„æˆä¸é›†æˆæ–¹æ³•è¯¦ç»†æ–‡æ¡£

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†æè¿°äº†æçŒ«ç›´æ’­åŠ©æ‰‹é¡¹ç›®ä¸­å„ä¸ªæ’ä»¶çš„å®é™…ç»„æˆã€æŠ€æœ¯æ¶æ„å’Œé›†æˆæ–¹æ³•ï¼Œä¸ºå¼€å‘è€…æä¾›å®Œæ•´çš„æ’ä»¶å¼€å‘å’Œé›†æˆæŒ‡å—ã€‚

## ğŸ—ï¸ é¡¹ç›®æ•´ä½“æ¶æ„

```
timao-douyin-live-manager/
â”œâ”€â”€ electron/                    # æ¡Œé¢åº”ç”¨å£³å±‚
â”œâ”€â”€ server/                      # åç«¯æœåŠ¡å±‚
â”‚   â”œâ”€â”€ app.py                  # Flask åç«¯ (REST/SSE)
â”‚   â””â”€â”€ app/main.py             # FastAPI åç«¯ (AST)
â”œâ”€â”€ AST_module/                 # è¯­éŸ³è¯†åˆ«æ¨¡å—
â”œâ”€â”€ DouyinLiveWebFetcher/       # æŠ–éŸ³ç›´æ’­æŠ“å–æ¨¡å—
â”œâ”€â”€ StreamCap/                  # å¤šå¹³å°ç›´æ’­å½•åˆ¶æ¨¡å—
â”œâ”€â”€ frontend/                   # å‰ç«¯ç•Œé¢
â””â”€â”€ docs/                       # æ–‡æ¡£ç›®å½•
```

---

## ğŸ¤ AST_module - è¯­éŸ³è¯†åˆ«æ¨¡å—

### æ¨¡å—ç»„æˆ

#### æ ¸å¿ƒæ–‡ä»¶ç»“æ„
```
AST_module/
â”œâ”€â”€ ast_service.py              # æ¨¡å—ç»Ÿä¸€å…¥å£
â”œâ”€â”€ audio_capture.py            # éŸ³é¢‘é‡‡é›†ä¸ç¼“å†²
â”œâ”€â”€ sensevoice_service.py       # SenseVoice/FunASR æ¨ç†å°è£…
â”œâ”€â”€ mock_transcription.py       # æ¨¡æ‹Ÿè½¬å†™æœåŠ¡
â”œâ”€â”€ config.py                   # é…ç½®ç®¡ç†
â”œâ”€â”€ postprocess.py              # åå¤„ç†å·¥å…·
â”œâ”€â”€ requirements.txt            # ä¾èµ–æ¸…å•
â”œâ”€â”€ templates/                  # Web ç•Œé¢æ¨¡æ¿
â””â”€â”€ docs/                       # æ¨¡å—æ–‡æ¡£
```

#### å…³é”®ç»„ä»¶è¯¦è§£

**1. ASTService (ast_service.py)**
```python
class ASTService:
    """è¯­éŸ³è½¬å†™æœåŠ¡çš„ç»Ÿä¸€å…¥å£"""
    
    def __init__(self, config: ASTConfig):
        self.config = config
        self.audio_capture = AudioCapture(config)
        self.transcription_service = self._get_transcription_service()
        self.callbacks = {}
    
    async def initialize(self) -> None:
        """åˆå§‹åŒ–æœåŠ¡"""
        
    async def start_transcription(self, room_id: str) -> None:
        """å¼€å§‹è½¬å†™"""
        
    async def stop_transcription(self) -> None:
        """åœæ­¢è½¬å†™"""
```

**2. AudioCapture (audio_capture.py)**
```python
class AudioCapture:
    """éŸ³é¢‘é‡‡é›†ä¸ç¯å½¢ç¼“å†²"""
    
    def __init__(self, config: ASTConfig):
        self.config = config
        self.buffer = RingBuffer(maxlen=config.buffer_size)
        self.is_capturing = False
    
    async def start_capture(self) -> None:
        """å¼€å§‹éŸ³é¢‘é‡‡é›†"""
        
    async def get_audio_chunk(self) -> np.ndarray:
        """è·å–éŸ³é¢‘ç‰‡æ®µ"""
```

**3. SenseVoiceService (sensevoice_service.py)**
```python
class SenseVoiceService:
    """SenseVoice/FunASR æ¨ç†å°è£…"""
    
    def __init__(self, config: SenseVoiceConfig):
        self.config = config
        self.model = None
    
    async def transcribe_audio(self, audio_data: np.ndarray) -> TranscriptionResult:
        """è½¬å†™éŸ³é¢‘æ•°æ®"""
```

### é›†æˆæ–¹æ³•

#### 1. åŸºç¡€é›†æˆ
```python
from AST_module import ASTService, create_ast_config, TranscriptionResult

# åˆ›å»ºé…ç½®
config = create_ast_config(
    chunk_duration=1.0,
    min_confidence=0.5,
    model_id="iic/SenseVoiceSmall"
)

# åˆ›å»ºæœåŠ¡å®ä¾‹
ast_service = ASTService(config)

# æ·»åŠ è½¬å†™å›è°ƒ
def handle_result(result: TranscriptionResult) -> None:
    print(f"è½¬å½•: {result.text} (ç½®ä¿¡åº¦: {result.confidence:.2f})")

ast_service.add_transcription_callback("demo", handle_result)

# å¯åŠ¨æœåŠ¡
async def main():
    await ast_service.initialize()
    await ast_service.start_transcription(room_id="demo-room")
    # ä¸šåŠ¡é€»è¾‘...
    await ast_service.stop_transcription()
    await ast_service.cleanup()
```

#### 2. ä¸ FastAPI é›†æˆ
```python
from fastapi import FastAPI
from AST_module import get_ast_service

app = FastAPI()
ast_service = get_ast_service()

@app.on_event("startup")
async def startup() -> None:
    await ast_service.initialize()

@app.on_event("shutdown")
async def shutdown() -> None:
    await ast_service.cleanup()

@app.websocket("/api/live_audio/ws")
async def websocket_endpoint(websocket: WebSocket):
    # WebSocket é›†æˆé€»è¾‘
    pass
```

#### 3. é…ç½®é€‰é¡¹
```python
# å¸¸ç”¨é…ç½®å‚æ•°
config = create_ast_config(
    model_id="iic/SenseVoiceSmall",     # æ¨¡å‹ID
    chunk_duration=1.0,                 # éŸ³é¢‘ç‰‡æ®µæ—¶é•¿(ç§’)
    min_confidence=0.5,                 # ç½®ä¿¡åº¦é˜ˆå€¼
    save_audio=True,                    # æ˜¯å¦ä¿å­˜éŸ³é¢‘æ–‡ä»¶
    buffer_size=10,                     # ç¯å½¢ç¼“å†²åŒºå¤§å°
    sample_rate=16000,                  # é‡‡æ ·ç‡
    channels=1                          # å£°é“æ•°
)
```

---

## ğŸ¯ DouyinLiveWebFetcher - æŠ–éŸ³ç›´æ’­æŠ“å–æ¨¡å—

### æ¨¡å—ç»„æˆ

#### æ ¸å¿ƒæ–‡ä»¶ç»“æ„
```
DouyinLiveWebFetcher/
â”œâ”€â”€ liveMan.py                  # ä¸»è¦æŠ“å–é€»è¾‘
â”œâ”€â”€ ac_signature.py             # ç­¾åç®—æ³•
â”œâ”€â”€ a_bogus.js                  # åçˆ¬è™«å‚æ•°ç”Ÿæˆ
â”œâ”€â”€ sign.js                     # ç­¾åç®—æ³•
â”œâ”€â”€ protobuf/                   # Protocol Buffer å®šä¹‰
â”‚   â”œâ”€â”€ douyin.proto           # æŠ–éŸ³åè®®å®šä¹‰
â”‚   â””â”€â”€ douyin.py              # ç”Ÿæˆçš„Pythonç±»
â”œâ”€â”€ requirements.txt            # ä¾èµ–æ¸…å•
â””â”€â”€ main.py                     # ç¤ºä¾‹ç”¨æ³•
```

#### å…³é”®ç»„ä»¶è¯¦è§£

**1. LiveManager (liveMan.py)**
```python
class LiveManager:
    """æŠ–éŸ³ç›´æ’­é—´ç®¡ç†å™¨"""
    
    def __init__(self, room_id: str):
        self.room_id = room_id
        self.ws_client = None
        self.is_running = False
    
    async def start(self) -> None:
        """å¼€å§‹æŠ“å–"""
        
    async def stop(self) -> None:
        """åœæ­¢æŠ“å–"""
        
    def on_message(self, message: dict) -> None:
        """å¤„ç†æ¶ˆæ¯å›è°ƒ"""
```

**2. æ¶ˆæ¯ç±»å‹å¤„ç†**
```python
class MessageHandler:
    """æ¶ˆæ¯å¤„ç†å™¨"""
    
    def handle_chat_message(self, data: dict) -> ChatMessage:
        """å¤„ç†èŠå¤©æ¶ˆæ¯"""
        
    def handle_gift_message(self, data: dict) -> GiftMessage:
        """å¤„ç†ç¤¼ç‰©æ¶ˆæ¯"""
        
    def handle_user_enter(self, data: dict) -> UserEnterMessage:
        """å¤„ç†ç”¨æˆ·è¿›å…¥æ¶ˆæ¯"""
```

### é›†æˆæ–¹æ³•

#### 1. åŸºç¡€é›†æˆ
```python
from DouyinLiveWebFetcher.liveMan import LiveManager

# åˆ›å»ºç›´æ’­é—´ç®¡ç†å™¨
room_id = "1234567890"  # æŠ–éŸ³ç›´æ’­é—´ID
live_manager = LiveManager(room_id)

# è®¾ç½®æ¶ˆæ¯å›è°ƒ
def on_chat_message(message):
    print(f"ç”¨æˆ· {message.user_name}: {message.content}")

def on_gift_message(message):
    print(f"ç”¨æˆ· {message.user_name} é€å‡ºäº† {message.gift_name}")

live_manager.set_chat_callback(on_chat_message)
live_manager.set_gift_callback(on_gift_message)

# å¯åŠ¨æŠ“å–
async def main():
    await live_manager.start()
    # ä¸šåŠ¡é€»è¾‘...
    await live_manager.stop()
```

#### 2. ä¸åç«¯æœåŠ¡é›†æˆ
```python
# server/ingest/comment_fetcher.py
from DouyinLiveWebFetcher.liveMan import LiveManager

class CommentFetcher:
    def __init__(self, config):
        self.config = config
        self.live_manager = None
        self.comment_buffer = RingBuffer(maxlen=200)
    
    async def start_fetching(self, room_id: str):
        self.live_manager = LiveManager(room_id)
        
        def handle_comment(message):
            comment = {
                'id': message.id,
                'user_name': message.user_name,
                'content': message.content,
                'timestamp': message.timestamp
            }
            self.comment_buffer.append(comment)
        
        self.live_manager.set_chat_callback(handle_comment)
        await self.live_manager.start()
```

#### 3. WebSocket é›†æˆ
```python
# é€šè¿‡ WebSocket æ¨é€æ¶ˆæ¯åˆ°å‰ç«¯
@app.websocket("/api/stream/comments")
async def stream_comments(websocket: WebSocket):
    await websocket.accept()
    
    def send_to_frontend(message):
        asyncio.create_task(websocket.send_text(json.dumps(message)))
    
    # æ³¨å†Œå›è°ƒ
    comment_fetcher.set_callback(send_to_frontend)
    
    try:
        while True:
            await asyncio.sleep(1)
    except WebSocketDisconnect:
        comment_fetcher.remove_callback(send_to_frontend)
```

---

## ğŸ¬ StreamCap - å¤šå¹³å°ç›´æ’­å½•åˆ¶æ¨¡å—

### æ¨¡å—ç»„æˆ

#### æ ¸å¿ƒæ–‡ä»¶ç»“æ„
```
StreamCap/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ platforms/          # å¹³å°å¤„ç†å™¨
â”‚   â”‚   â”‚   â””â”€â”€ platform_handlers/
â”‚   â”‚   â”‚       â”œâ”€â”€ base.py     # åŸºç¡€å¤„ç†å™¨
â”‚   â”‚   â”‚       â””â”€â”€ handlers.py # å…·ä½“å¹³å°å®ç°
â”‚   â”‚   â”œâ”€â”€ media/              # åª’ä½“å¤„ç†
â”‚   â”‚   â”‚   â””â”€â”€ ffmpeg_builders/
â”‚   â”‚   â”‚       â”œâ”€â”€ audio/      # éŸ³é¢‘ç¼–ç å™¨
â”‚   â”‚   â”‚       â””â”€â”€ video/      # è§†é¢‘ç¼–ç å™¨
â”‚   â”‚   â””â”€â”€ recording/          # å½•åˆ¶ç®¡ç†
â”‚   â”‚       â”œâ”€â”€ stream_manager.py
â”‚   â”‚       â””â”€â”€ record_manager.py
â”‚   â””â”€â”€ utils/                  # å·¥å…·ç±»
â”œâ”€â”€ main.py                     # åº”ç”¨å…¥å£
â””â”€â”€ requirements.txt            # ä¾èµ–æ¸…å•
```

#### å…³é”®ç»„ä»¶è¯¦è§£

**1. PlatformHandler (platform_handlers/base.py)**
```python
class PlatformHandler(abc.ABC):
    """å¹³å°å¤„ç†å™¨åŸºç±»"""
    
    @abc.abstractmethod
    async def get_stream_info(self, live_url: str) -> StreamData:
        """è·å–æµåª’ä½“ä¿¡æ¯"""
        pass

class DouyinHandler(PlatformHandler):
    """æŠ–éŸ³å¹³å°å¤„ç†å™¨"""
    
    async def get_stream_info(self, live_url: str) -> StreamData:
        # æŠ–éŸ³ç‰¹å®šçš„æµåª’ä½“è§£æé€»è¾‘
        pass
```

**2. FFmpegCommandBuilder (media/ffmpeg_builders/)**
```python
class WAVCommandBuilder(FFmpegCommandBuilder):
    """WAVéŸ³é¢‘ç¼–ç å™¨"""
    
    def build_command(self) -> list[str]:
        command = self._get_basic_ffmpeg_command()
        additional_commands = [
            "-map", "0:a",
            "-c:a", "pcm_s16le",
            "-ar", "44100",
            "-ac", "2",
            "-f", "wav",
            self.full_path,
        ]
        command.extend(additional_commands)
        return command
```

**3. LiveStreamRecorder (recording/stream_manager.py)**
```python
class LiveStreamRecorder:
    """ç›´æ’­æµå½•åˆ¶å™¨"""
    
    async def fetch_stream(self) -> StreamData:
        """è·å–æµåª’ä½“ä¿¡æ¯"""
        
    async def start_recording(self, stream_info: StreamData):
        """å¼€å§‹å½•åˆ¶"""
        
    async def stop_recording(self):
        """åœæ­¢å½•åˆ¶"""
```

### é›†æˆæ–¹æ³•

#### 1. åŸºç¡€é›†æˆ
```python
from StreamCap.app.core.platforms.platform_handlers import DouyinHandler
from StreamCap.app.core.media.ffmpeg_builders.audio import WAVCommandBuilder

# åˆ›å»ºæŠ–éŸ³å¤„ç†å™¨
douyin_handler = DouyinHandler(
    proxy=None,
    cookies=None,
    record_quality="OD"
)

# è·å–æµåª’ä½“ä¿¡æ¯
stream_info = await douyin_handler.get_stream_info("https://live.douyin.com/123456")

# åˆ›å»ºWAVå½•åˆ¶å™¨
wav_builder = WAVCommandBuilder(
    record_url=stream_info.record_url,
    full_path="output.wav"
)

# ç”ŸæˆFFmpegå‘½ä»¤
ffmpeg_command = wav_builder.build_command()
```

#### 2. ä¸ASTæ¨¡å—é›†æˆ
```python
# ç»“åˆStreamCapå’ŒASTæ¨¡å—å®ç°éŸ³é¢‘æµå½•åˆ¶+è½¬å†™
class AudioStreamProcessor:
    def __init__(self):
        self.streamcap_handler = DouyinHandler()
        self.ast_service = ASTService()
    
    async def process_live_stream(self, live_url: str):
        # 1. è·å–æµåª’ä½“ä¿¡æ¯
        stream_info = await self.streamcap_handler.get_stream_info(live_url)
        
        # 2. å¼€å§‹å½•åˆ¶éŸ³é¢‘
        recorder = LiveStreamRecorder(stream_info)
        await recorder.start_recording()
        
        # 3. åŒæ—¶å¯åŠ¨è¯­éŸ³è½¬å†™
        await self.ast_service.start_transcription()
        
        # 4. å¤„ç†éŸ³é¢‘æµ
        while True:
            audio_chunk = await recorder.get_audio_chunk()
            result = await self.ast_service.transcribe_audio(audio_chunk)
            print(f"è½¬å†™ç»“æœ: {result.text}")
```

#### 3. æ”¯æŒçš„éŸ³é¢‘æ ¼å¼
```python
# æ”¯æŒçš„éŸ³é¢‘ç¼–ç å™¨
from StreamCap.app.core.media.ffmpeg_builders.audio import (
    WAVCommandBuilder,    # æ— æŸéŸ³é¢‘ï¼Œé€‚åˆè¯­éŸ³è¯†åˆ«
    MP3CommandBuilder,    # é€šç”¨æ ¼å¼
    AACCommandBuilder,    # é«˜è´¨é‡å‹ç¼©
    M4ACommandBuilder,    # Appleæ ¼å¼
    WMACommandBuilder     # Windowsæ ¼å¼
)

# æ ¹æ®éœ€æ±‚é€‰æ‹©åˆé€‚çš„ç¼–ç å™¨
def get_audio_builder(format_type: str, **kwargs):
    builders = {
        'wav': WAVCommandBuilder,
        'mp3': MP3CommandBuilder,
        'aac': AACCommandBuilder,
        'm4a': M4ACommandBuilder,
        'wma': WMACommandBuilder
    }
    return builders[format_type](**kwargs)
```

---

## ğŸ”Œ æ’ä»¶é›†æˆæœ€ä½³å®è·µ

### 1. æ¨¡å—åŒ–è®¾è®¡åŸåˆ™

#### ä¾èµ–æ³¨å…¥æ¨¡å¼
```python
class PluginManager:
    """æ’ä»¶ç®¡ç†å™¨"""
    
    def __init__(self):
        self.plugins = {}
    
    def register_plugin(self, name: str, plugin: Plugin):
        """æ³¨å†Œæ’ä»¶"""
        self.plugins[name] = plugin
    
    def get_plugin(self, name: str) -> Plugin:
        """è·å–æ’ä»¶"""
        return self.plugins.get(name)
    
    async def initialize_all(self):
        """åˆå§‹åŒ–æ‰€æœ‰æ’ä»¶"""
        for plugin in self.plugins.values():
            await plugin.initialize()
```

#### äº‹ä»¶é©±åŠ¨æ¶æ„
```python
class EventBus:
    """äº‹ä»¶æ€»çº¿"""
    
    def __init__(self):
        self.subscribers = {}
    
    def subscribe(self, event_type: str, callback: callable):
        """è®¢é˜…äº‹ä»¶"""
        if event_type not in self.subscribers:
            self.subscribers[event_type] = []
        self.subscribers[event_type].append(callback)
    
    async def publish(self, event_type: str, data: Any):
        """å‘å¸ƒäº‹ä»¶"""
        if event_type in self.subscribers:
            for callback in self.subscribers[event_type]:
                await callback(data)
```

### 2. é…ç½®ç®¡ç†

#### ç»Ÿä¸€é…ç½®æ¥å£
```python
from dataclasses import dataclass
from typing import Optional, Dict, Any

@dataclass
class PluginConfig:
    """æ’ä»¶é…ç½®åŸºç±»"""
    enabled: bool = True
    name: str = ""
    version: str = "1.0.0"
    dependencies: list = None
    
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸"""
        return {
            'enabled': self.enabled,
            'name': self.name,
            'version': self.version,
            'dependencies': self.dependencies or []
        }

@dataclass
class ASTConfig(PluginConfig):
    """ASTæ¨¡å—é…ç½®"""
    model_id: str = "iic/SenseVoiceSmall"
    chunk_duration: float = 1.0
    min_confidence: float = 0.5
    save_audio: bool = False

@dataclass
class DouyinConfig(PluginConfig):
    """æŠ–éŸ³æŠ“å–é…ç½®"""
    room_id: str = ""
    proxy: Optional[str] = None
    cookies: Optional[str] = None
    buffer_size: int = 200
```

### 3. é”™è¯¯å¤„ç†å’Œé™çº§ç­–ç•¥

#### æ’ä»¶é™çº§æœºåˆ¶
```python
class PluginWithFallback:
    """å¸¦é™çº§åŠŸèƒ½çš„æ’ä»¶"""
    
    def __init__(self, primary_plugin: Plugin, fallback_plugin: Plugin):
        self.primary = primary_plugin
        self.fallback = fallback_plugin
        self.using_fallback = False
    
    async def execute(self, *args, **kwargs):
        """æ‰§è¡Œæ’ä»¶åŠŸèƒ½"""
        try:
            if not self.using_fallback:
                return await self.primary.execute(*args, **kwargs)
            else:
                return await self.fallback.execute(*args, **kwargs)
        except Exception as e:
            if not self.using_fallback:
                logger.warning(f"Primary plugin failed: {e}, switching to fallback")
                self.using_fallback = True
                return await self.fallback.execute(*args, **kwargs)
            else:
                raise e
```

#### å¥åº·æ£€æŸ¥æœºåˆ¶
```python
class HealthChecker:
    """å¥åº·æ£€æŸ¥å™¨"""
    
    async def check_plugin_health(self, plugin: Plugin) -> bool:
        """æ£€æŸ¥æ’ä»¶å¥åº·çŠ¶æ€"""
        try:
            if hasattr(plugin, 'health_check'):
                return await plugin.health_check()
            return True
        except Exception:
            return False
    
    async def monitor_plugins(self, plugins: Dict[str, Plugin]):
        """ç›‘æ§æ‰€æœ‰æ’ä»¶"""
        while True:
            for name, plugin in plugins.items():
                is_healthy = await self.check_plugin_health(plugin)
                if not is_healthy:
                    logger.error(f"Plugin {name} is unhealthy")
            await asyncio.sleep(30)  # æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
```

### 4. æ€§èƒ½ä¼˜åŒ–

#### å¼‚æ­¥å¤„ç†
```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

class AsyncPluginManager:
    """å¼‚æ­¥æ’ä»¶ç®¡ç†å™¨"""
    
    def __init__(self, max_workers: int = 4):
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
    
    async def run_cpu_intensive_task(self, func, *args):
        """è¿è¡ŒCPUå¯†é›†å‹ä»»åŠ¡"""
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(self.executor, func, *args)
    
    async def process_audio_chunk(self, audio_data: np.ndarray):
        """å¤„ç†éŸ³é¢‘å—"""
        # åœ¨åå°çº¿ç¨‹ä¸­è¿è¡ŒCPUå¯†é›†å‹ä»»åŠ¡
        result = await self.run_cpu_intensive_task(
            self.ast_service.transcribe_audio, audio_data
        )
        return result
```

#### ç¼“å­˜æœºåˆ¶
```python
from functools import lru_cache
import hashlib

class CachedPlugin:
    """å¸¦ç¼“å­˜çš„æ’ä»¶"""
    
    @lru_cache(maxsize=128)
    def get_model(self, model_id: str):
        """è·å–æ¨¡å‹ï¼ˆå¸¦ç¼“å­˜ï¼‰"""
        # æ¨¡å‹åŠ è½½é€»è¾‘
        pass
    
    def _cache_key(self, data: bytes) -> str:
        """ç”Ÿæˆç¼“å­˜é”®"""
        return hashlib.md5(data).hexdigest()
```

---

## ğŸš€ éƒ¨ç½²å’Œè¿ç»´

### 1. Docker å®¹å™¨åŒ–

#### ASTæ¨¡å—å®¹å™¨åŒ–
```dockerfile
# AST_module/Dockerfile
FROM python:3.10-slim

WORKDIR /app

# å®‰è£…ç³»ç»Ÿä¾èµ–
RUN apt-get update && apt-get install -y \
    ffmpeg \
    portaudio19-dev \
    && rm -rf /var/lib/apt/lists/*

# å®‰è£…Pythonä¾èµ–
COPY requirements.txt .
RUN pip install -r requirements.txt

# å¤åˆ¶ä»£ç 
COPY . .

# è®¾ç½®ç¯å¢ƒå˜é‡
ENV PYTHONPATH=/app

# æš´éœ²ç«¯å£
EXPOSE 8000

# å¯åŠ¨å‘½ä»¤
CMD ["python", "ast_service.py"]
```

#### æœåŠ¡ç¼–æ’
```yaml
# docker-compose.yml
version: '3.8'

services:
  ast-service:
    build: ./AST_module
    ports:
      - "8001:8000"
    environment:
      - MODEL_PATH=/models
    volumes:
      - ./models:/models
      - ./audio_logs:/app/audio_logs
    
  douyin-fetcher:
    build: ./DouyinLiveWebFetcher
    ports:
      - "8002:8000"
    depends_on:
      - redis
    
  streamcap:
    build: ./StreamCap
    ports:
      - "8003:6006"
    volumes:
      - ./recordings:/app/recordings
    
  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
```

### 2. ç›‘æ§å’Œæ—¥å¿—

#### ç»Ÿä¸€æ—¥å¿—æ ¼å¼
```python
import logging
import json
from datetime import datetime

class StructuredLogger:
    """ç»“æ„åŒ–æ—¥å¿—è®°å½•å™¨"""
    
    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
    
    def log_event(self, event_type: str, data: dict, level: str = "INFO"):
        """è®°å½•ç»“æ„åŒ–äº‹ä»¶"""
        log_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'event_type': event_type,
            'plugin': self.logger.name,
            'data': data
        }
        
        if level == "ERROR":
            self.logger.error(json.dumps(log_data))
        elif level == "WARNING":
            self.logger.warning(json.dumps(log_data))
        else:
            self.logger.info(json.dumps(log_data))
```

#### æ€§èƒ½ç›‘æ§
```python
import time
from functools import wraps

def monitor_performance(func):
    """æ€§èƒ½ç›‘æ§è£…é¥°å™¨"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.time()
        try:
            result = await func(*args, **kwargs)
            execution_time = time.time() - start_time
            
            # è®°å½•æ€§èƒ½æ•°æ®
            logger.info(f"Function {func.__name__} executed in {execution_time:.3f}s")
            return result
        except Exception as e:
            execution_time = time.time() - start_time
            logger.error(f"Function {func.__name__} failed after {execution_time:.3f}s: {e}")
            raise
    return wrapper
```

---

## ğŸ“š å¼€å‘æŒ‡å—

### 1. æ–°æ’ä»¶å¼€å‘æ¨¡æ¿

```python
# æ’ä»¶å¼€å‘æ¨¡æ¿
from abc import ABC, abstractmethod
from typing import Any, Dict, Optional
import asyncio

class BasePlugin(ABC):
    """æ’ä»¶åŸºç±»"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.is_initialized = False
        self.is_running = False
    
    @abstractmethod
    async def initialize(self) -> None:
        """åˆå§‹åŒ–æ’ä»¶"""
        pass
    
    @abstractmethod
    async def start(self) -> None:
        """å¯åŠ¨æ’ä»¶"""
        pass
    
    @abstractmethod
    async def stop(self) -> None:
        """åœæ­¢æ’ä»¶"""
        pass
    
    @abstractmethod
    async def cleanup(self) -> None:
        """æ¸…ç†èµ„æº"""
        pass
    
    async def health_check(self) -> bool:
        """å¥åº·æ£€æŸ¥"""
        return self.is_running

class MyCustomPlugin(BasePlugin):
    """è‡ªå®šä¹‰æ’ä»¶ç¤ºä¾‹"""
    
    async def initialize(self) -> None:
        """åˆå§‹åŒ–é€»è¾‘"""
        # åˆå§‹åŒ–ä»£ç 
        self.is_initialized = True
    
    async def start(self) -> None:
        """å¯åŠ¨é€»è¾‘"""
        if not self.is_initialized:
            await self.initialize()
        # å¯åŠ¨ä»£ç 
        self.is_running = True
    
    async def stop(self) -> None:
        """åœæ­¢é€»è¾‘"""
        # åœæ­¢ä»£ç 
        self.is_running = False
    
    async def cleanup(self) -> None:
        """æ¸…ç†é€»è¾‘"""
        # æ¸…ç†ä»£ç 
        pass
```

### 2. æµ‹è¯•æ¡†æ¶

```python
# æ’ä»¶æµ‹è¯•æ¨¡æ¿
import pytest
import asyncio
from unittest.mock import Mock, AsyncMock

class TestMyCustomPlugin:
    """æ’ä»¶æµ‹è¯•ç±»"""
    
    @pytest.fixture
    def plugin_config(self):
        """æµ‹è¯•é…ç½®"""
        return {
            'enabled': True,
            'name': 'test_plugin',
            'version': '1.0.0'
        }
    
    @pytest.fixture
    def plugin(self, plugin_config):
        """æ’ä»¶å®ä¾‹"""
        return MyCustomPlugin(plugin_config)
    
    @pytest.mark.asyncio
    async def test_plugin_initialization(self, plugin):
        """æµ‹è¯•æ’ä»¶åˆå§‹åŒ–"""
        await plugin.initialize()
        assert plugin.is_initialized is True
    
    @pytest.mark.asyncio
    async def test_plugin_start_stop(self, plugin):
        """æµ‹è¯•æ’ä»¶å¯åŠ¨åœæ­¢"""
        await plugin.start()
        assert plugin.is_running is True
        
        await plugin.stop()
        assert plugin.is_running is False
    
    @pytest.mark.asyncio
    async def test_health_check(self, plugin):
        """æµ‹è¯•å¥åº·æ£€æŸ¥"""
        # æœªå¯åŠ¨æ—¶åº”è¯¥è¿”å›False
        assert await plugin.health_check() is False
        
        # å¯åŠ¨ååº”è¯¥è¿”å›True
        await plugin.start()
        assert await plugin.health_check() is True
```

---

## ğŸ“– æ€»ç»“

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†æçŒ«ç›´æ’­åŠ©æ‰‹é¡¹ç›®ä¸­å„ä¸ªæ’ä»¶çš„ç»„æˆå’Œé›†æˆæ–¹æ³•ï¼š

1. **AST_module**: æä¾›è¯­éŸ³è¯†åˆ«èƒ½åŠ›ï¼Œæ”¯æŒSenseVoice/FunASRæ¨¡å‹
2. **DouyinLiveWebFetcher**: æä¾›æŠ–éŸ³ç›´æ’­æ•°æ®æŠ“å–èƒ½åŠ›
3. **StreamCap**: æä¾›å¤šå¹³å°ç›´æ’­å½•åˆ¶èƒ½åŠ›

æ¯ä¸ªæ¨¡å—éƒ½éµå¾ªæ¨¡å—åŒ–è®¾è®¡åŸåˆ™ï¼Œæ”¯æŒå¼‚æ­¥å¤„ç†ã€é”™è¯¯é™çº§ã€å¥åº·æ£€æŸ¥ç­‰ä¼ä¸šçº§ç‰¹æ€§ã€‚é€šè¿‡ç»Ÿä¸€çš„æ’ä»¶ç®¡ç†å™¨å’Œäº‹ä»¶é©±åŠ¨æ¶æ„ï¼Œå¯ä»¥å®ç°æ’ä»¶é—´çš„æ¾è€¦åˆé›†æˆã€‚

å¼€å‘è€…å¯ä»¥æ ¹æ®æœ¬æ–‡æ¡£å¿«é€Ÿç†è§£é¡¹ç›®æ¶æ„ï¼Œå¼€å‘æ–°çš„æ’ä»¶ï¼Œæˆ–è€…é›†æˆç°æœ‰æ’ä»¶åˆ°è‡ªå·±çš„é¡¹ç›®ä¸­ã€‚

---

*æ–‡æ¡£ç‰ˆæœ¬: v1.0*  
*æœ€åæ›´æ–°: 2025å¹´1æœˆ*  
*ç»´æŠ¤è€…: æçŒ«å›¢é˜Ÿ*
