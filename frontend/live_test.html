<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>ç›´æ’­è½¬å½• & å¼¹å¹•è”åˆæµ‹è¯•</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      color-scheme: dark;
      --bg: #0f172a;
      --panel: rgba(15, 23, 42, 0.78);
      --accent: #38bdf8;
      --accent-strong: #0ea5e9;
      --text: #e2e8f0;
      --muted: rgba(148, 163, 184, 0.7);
      --border: rgba(148, 163, 184, 0.18);
      font-family: "Segoe UI", "PingFang SC", "Microsoft YaHei", sans-serif;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at top, #1e293b, #020617);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 40px 16px;
    }

    .container {
      width: min(1200px, 100%);
      background: rgba(15, 23, 42, 0.85);
      border-radius: 24px;
      padding: 32px;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.4);
      border: 1px solid var(--border);
    }

    h1 {
      margin: 0 0 16px;
      font-size: 30px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .control-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 18px;
      align-items: center;
    }

    input[type="text"] {
      flex: 1 1 280px;
      padding: 12px 16px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.6);
      color: var(--text);
      font-size: 16px;
      outline: none;
      transition: border-color 0.2s ease;
    }

    input[type="text"]:focus {
      border-color: var(--accent);
    }

    button {
      padding: 12px 24px;
      border-radius: 12px;
      border: none;
      font-size: 16px;
      cursor: pointer;
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      color: white;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    button.secondary {
      background: rgba(148, 163, 184, 0.25);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 18px 32px rgba(56, 189, 248, 0.25);
    }

    .status {
      margin-bottom: 18px;
      padding: 12px 16px;
      border-radius: 12px;
      background: rgba(148, 163, 184, 0.1);
      border: 1px solid var(--border);
      min-height: 48px;
      font-size: 14px;
      line-height: 1.5;
    }

    .layout {
      display: grid;
      grid-template-columns: 2fr 1.1fr;
      gap: 24px;
    }

    .panel {
      background: var(--panel);
      border-radius: 20px;
      padding: 20px;
      border: 1px solid var(--border);
      min-height: 420px;
      display: flex;
      flex-direction: column;
    }

    .panel h2 {
      margin: 0 0 16px;
      font-size: 20px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    #transcriptionList,
    #chatList {
      list-style: none;
      margin: 0;
      padding: 0;
      flex: 1;
      overflow-y: auto;
      scrollbar-width: thin;
    }

    #transcriptionList li,
    #chatList li {
      border-bottom: 1px solid rgba(148, 163, 184, 0.08);
      padding: 10px 0;
      display: grid;
      gap: 6px;
    }

    #transcriptionList li:last-child,
    #chatList li:last-child {
      border-bottom: none;
    }

    .transcription-text {
      font-size: 16px;
      color: rgba(226, 232, 240, 0.96);
    }

    .transcription-final {
      color: #fef3c7;
      font-weight: 600;
    }

    .transcription-meta {
      font-size: 12px;
      color: var(--muted);
    }

    .chat-nickname {
      font-weight: 600;
      color: var(--accent);
    }

    .chat-content {
      color: rgba(226, 232, 240, 0.9);
      word-break: break-word;
    }

    .right-column {
      display: grid;
      grid-template-rows: 1fr auto;
      gap: 20px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }

    thead th {
      text-align: left;
      padding: 8px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      color: rgba(226, 232, 240, 0.6);
      font-weight: 500;
    }

    tbody td {
      padding: 10px 8px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.08);
      vertical-align: middle;
    }

    tbody tr:last-child td {
      border-bottom: none;
    }

    .rank-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      object-fit: cover;
      margin-right: 10px;
      border: 1px solid rgba(148, 163, 184, 0.3);
    }

    .rank-user {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    @media (max-width: 960px) {
      .layout {
        grid-template-columns: 1fr;
      }
      .right-column {
        grid-template-rows: auto auto;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ§ª è¯­éŸ³è½¬å½• + å¼¹å¹•è”åˆæµ‹è¯•</h1>
    <div class="control-bar">
      <input id="liveIdInput" type="text" placeholder="è¾“å…¥ç›´æ’­é—´å·ï¼Œä¾‹å¦‚ 812922801191" />
      <button id="startBtn">å¼€å§‹æµ‹è¯•</button>
      <button id="stopBtn" class="secondary">åœæ­¢</button>
    </div>
    <div id="status" class="status">ç­‰å¾…å¯åŠ¨â€¦</div>
    <div class="layout">
      <section class="panel">
        <h2>ğŸ“ å®æ—¶è½¬å½•</h2>
        <ul id="transcriptionList"></ul>
      </section>
      <section class="right-column">
        <div class="panel">
          <h2>ğŸ’¬ å®æ—¶å¼¹å¹•</h2>
          <ul id="chatList"></ul>
        </div>
        <div class="panel">
          <h2>ğŸ† ç›´æ’­é—´æ’è¡Œæ¦œ</h2>
          <table>
            <thead>
              <tr>
                <th style="width: 60px;">æ’å</th>
                <th>ç”¨æˆ·</th>
                <th style="width: 120px;">è´¡çŒ®å€¼</th>
              </tr>
            </thead>
            <tbody id="rankBody">
              <tr><td colspan="3" style="text-align:center; padding:20px; color: rgba(226,232,240,0.4);">æš‚æ— æ•°æ®</td></tr>
            </tbody>
          </table>
        </div>
      </section>
    </div>
  </div>

  <script>
    const statusBox = document.getElementById('status');
    const chatList = document.getElementById('chatList');
    const transcriptionList = document.getElementById('transcriptionList');
    const rankBody = document.getElementById('rankBody');
    const liveIdInput = document.getElementById('liveIdInput');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    stopBtn.disabled = true;

    let eventSource = null;
    let chatBuffer = [];
    let transcriptionBuffer = [];
    const MAX_CHAT = 100;
    const MAX_TRANS = 120;

    function updateStatus(message, tone = 'info') {
      const colorMap = {
        info: 'rgba(148, 163, 184, 0.7)',
        success: '#38bdf8',
        error: '#f87171',
        warning: '#facc15',
      };
      statusBox.style.borderColor = colorMap[tone] || colorMap.info;
      statusBox.textContent = message;
    }

    function ensureEventSource() {
      if (eventSource) return;
      eventSource = new EventSource('/api/live-test/stream');
      eventSource.onopen = () => updateStatus('SSE é€šé“å·²å»ºç«‹ï¼Œç­‰å¾…æ•°æ®â€¦', 'info');
      eventSource.onerror = () => updateStatus('SSE é€šé“å¼‚å¸¸ï¼Œå¯èƒ½å·²æ–­å¼€ã€‚', 'warning');
      eventSource.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          handleEvent(data);
        } catch (err) {
          console.error('è§£ææ¶ˆæ¯å¤±è´¥', err);
        }
      };
    }

    function disposeEventSource() {
      if (eventSource) {
        eventSource.close();
        eventSource = null;
      }
    }

    function handleEvent(event) {
      const { type, payload } = event;
      switch (type) {
        case 'status': {
          const stage = payload?.stage;
          const source = payload?.source || 'live_test';
          if (source === 'live_test') {
            if (stage === 'live_test_starting') {
              updateStatus('æ­£åœ¨å¯åŠ¨è”åˆæµ‹è¯•â€¦', 'info');
            } else if (stage === 'live_test_started') {
              updateStatus('è”åˆæµ‹è¯•å·²å¯åŠ¨ï¼Œç­‰å¾…æ•°æ®ã€‚', 'success');
            } else if (stage === 'live_test_stopped') {
              updateStatus('è”åˆæµ‹è¯•å·²åœæ­¢ã€‚', 'warning');
            } else if (stage === 'live_test_error') {
              updateStatus(`è”åˆæµ‹è¯•å¼‚å¸¸ï¼š${payload?.message || 'æœªçŸ¥é”™è¯¯'}`, 'error');
            }
          } else if (source === 'douyin') {
            if (stage === 'connected') {
              updateStatus('å·²è¿æ¥ç›´æ’­é—´å¼¹å¹•ã€‚', 'success');
            } else if (stage === 'room_ready') {
              updateStatus(`ç›´æ’­é—´å°±ç»ª (room_id=${payload.room_id || 'æœªçŸ¥'})`, 'info');
            } else if (stage === 'closed' || stage === 'stopped') {
              updateStatus('å¼¹å¹•è¿æ¥å·²å…³é—­ã€‚', 'warning');
            }
          }
          break;
        }
        case 'error':
          updateStatus(`æŠ“å–å¼‚å¸¸ï¼š${payload?.message || 'æœªçŸ¥é”™è¯¯'}`, 'error');
          break;
        case 'transcription':
          appendTranscription(payload);
          break;
        case 'chat':
          appendChat(payload);
          break;
        case 'gift':
          appendChat({
            nickname: payload?.nickname,
            content: `ğŸ é€å‡º ${payload?.gift_name || ''} x${payload?.count || 1}`,
          });
          break;
        case 'room_rank':
          renderRank(payload?.ranks || []);
          break;
        default:
          break;
      }
    }

    function appendTranscription(payload) {
      if (!payload?.text) return;
      const record = {
        text: payload.text,
        confidence: payload.confidence ?? 0,
        isFinal: Boolean(payload.is_final),
        timestamp: payload.timestamp ? new Date(payload.timestamp * 1000) : new Date(),
      };
      transcriptionBuffer.push(record);
      if (transcriptionBuffer.length > MAX_TRANS) {
        transcriptionBuffer = transcriptionBuffer.slice(transcriptionBuffer.length - MAX_TRANS);
      }
      transcriptionList.innerHTML = '';
      for (const item of transcriptionBuffer.slice(-MAX_TRANS).reverse()) {
        const li = document.createElement('li');
        const textEl = document.createElement('div');
        textEl.className = 'transcription-text';
        textEl.textContent = item.text;
        if (item.isFinal) textEl.classList.add('transcription-final');

        const metaEl = document.createElement('div');
        metaEl.className = 'transcription-meta';
        const timeStr = item.timestamp.toLocaleTimeString();
        metaEl.textContent = `${timeStr} Â· ç½®ä¿¡åº¦ ${(item.confidence * 100).toFixed(1)}% ${item.isFinal ? '(æœ€ç»ˆ)' : '(ä¸´æ—¶)'}`;

        li.appendChild(textEl);
        li.appendChild(metaEl);
        transcriptionList.appendChild(li);
      }
    }

    function appendChat(data) {
      if (!data?.nickname && !data?.content) return;
      chatBuffer.push({
        nickname: data.nickname || 'åŒ¿å',
        content: data.content || '',
        ts: Date.now(),
      });
      if (chatBuffer.length > MAX_CHAT) {
        chatBuffer = chatBuffer.slice(chatBuffer.length - MAX_CHAT);
      }
      chatList.innerHTML = '';
      for (const item of chatBuffer.slice(-MAX_CHAT).reverse()) {
        const li = document.createElement('li');
        const nick = document.createElement('div');
        nick.className = 'chat-nickname';
        nick.textContent = item.nickname;
        const content = document.createElement('div');
        content.className = 'chat-content';
        content.textContent = item.content;
        li.appendChild(nick);
        li.appendChild(content);
        chatList.appendChild(li);
      }
    }

    function renderRank(ranks) {
      if (!Array.isArray(ranks) || ranks.length === 0) {
        rankBody.innerHTML = '<tr><td colspan="3" style="text-align:center; padding:20px; color: rgba(226,232,240,0.4);">æš‚æ— æ’è¡Œæ¦œæ•°æ®</td></tr>';
        return;
      }
      rankBody.innerHTML = '';
      ranks.slice(0, 10).forEach((item) => {
        const tr = document.createElement('tr');

        const rankTd = document.createElement('td');
        rankTd.textContent = item.rank ?? '-';
        tr.appendChild(rankTd);

        const userTd = document.createElement('td');
        const wrap = document.createElement('div');
        wrap.className = 'rank-user';
        if (item.avatar) {
          const img = document.createElement('img');
          img.src = item.avatar;
          img.alt = item.nickname || '';
          img.className = 'rank-avatar';
          img.referrerPolicy = 'no-referrer';
          wrap.appendChild(img);
        }
        const name = document.createElement('span');
        name.textContent = item.nickname || 'åŒ¿åç”¨æˆ·';
        wrap.appendChild(name);
        userTd.appendChild(wrap);
        tr.appendChild(userTd);

        const scoreTd = document.createElement('td');
        scoreTd.textContent = item.score_str || item.score || '-';
        tr.appendChild(scoreTd);

        rankBody.appendChild(tr);
      });
    }

    function resetTranscriptions() {
      transcriptionBuffer = [];
      transcriptionList.innerHTML = '';
    }

    function resetChats() {
      chatBuffer = [];
      chatList.innerHTML = '';
      renderRank([]);
    }

    async function startMonitor() {
      const liveId = liveIdInput.value.trim();
      if (!liveId) {
        updateStatus('è¯·å…ˆè¾“å…¥ç›´æ’­é—´å·ã€‚', 'warning');
        liveIdInput.focus();
        return;
      }
      startBtn.disabled = true;
      stopBtn.disabled = false;
      resetTranscriptions();
      resetChats();
      ensureEventSource();
      try {
        const resp = await fetch('/api/live-test/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ live_id: liveId }),
        });
        if (!resp.ok) {
          const detail = await resp.json().catch(() => ({}));
          throw new Error(detail.detail || 'å¯åŠ¨å¤±è´¥');
        }
        updateStatus(`å·²æäº¤æµ‹è¯•ä»»åŠ¡ï¼Œç›´æ’­é—´ ${liveId}`, 'info');
      } catch (error) {
        console.error(error);
        updateStatus(`å¯åŠ¨å¤±è´¥ï¼š${error.message}`, 'error');
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    }

    async function stopMonitor() {
      stopBtn.disabled = true;
      try {
        await fetch('/api/live-test/stop', { method: 'POST' });
      } catch (error) {
        console.error(error);
      }
      disposeEventSource();
      updateStatus('å·²åœæ­¢æµ‹è¯•ã€‚', 'warning');
      resetTranscriptions();
      resetChats();
      setTimeout(() => {
        startBtn.disabled = false;
      }, 200);
    }

    startBtn.addEventListener('click', startMonitor);
    stopBtn.addEventListener('click', stopMonitor);

    window.addEventListener('beforeunload', () => {
      disposeEventSource();
    });
  </script>
</body>
</html>
