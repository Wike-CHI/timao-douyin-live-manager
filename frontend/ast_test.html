<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ± æçŒ«ç›´æ’­åŠ©æ‰‹ - ASTè¯­éŸ³è½¬å½•æµ‹è¯•</title>
    <link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css">
    <script src="https://unpkg.com/vue@2/dist/vue.js"></script>
    <script src="https://unpkg.com/element-ui/lib/index.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Microsoft YaHei", "å¾®è½¯é›…é»‘", sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .cat-logo {
            font-size: 4em;
            margin-bottom: 10px;
            animation: bounce 2s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .title {
            font-size: 2.5em;
            font-weight: bold;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            font-size: 1.2em;
        }

        .control-panel {
            background: #f8fafc;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .status-panel {
            background: #f0f9ff;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .transcription-panel {
            background: #fefefe;
            border-radius: 15px;
            padding: 20px;
            min-height: 300px;
            border: 2px dashed #e2e8f0;
        }

        .transcription-item {
            background: #f1f5f9;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            border-left: 4px solid #06b6d4;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .transcription-text {
            font-size: 1.1em;
            color: #334155;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .transcription-meta {
            font-size: 0.9em;
            color: #64748b;
        }

        .confidence-high {
            border-left-color: #22c55e;
        }

        .confidence-medium {
            border-left-color: #f59e0b;
        }

        .confidence-low {
            border-left-color: #ef4444;
        }

        .status-dot {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-running {
            background: #22c55e;
            animation: pulse 2s infinite;
        }

        .status-stopped {
            background: #94a3b8;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); }
            100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-item {
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            color: #64748b;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div id="app" class="app-container">
        <!-- å¤´éƒ¨ -->
        <div class="header">
            <div class="cat-logo">ğŸ±</div>
            <h1 class="title">æçŒ«ç›´æ’­åŠ©æ‰‹</h1>
            <p class="subtitle">ASTè¯­éŸ³è½¬å½•æ¨¡å—æµ‹è¯•ç•Œé¢</p>
        </div>

        <!-- æ§åˆ¶é¢æ¿ -->
        <div class="control-panel">
            <h3 style="margin-bottom: 15px;">ğŸ›ï¸ æ§åˆ¶é¢æ¿</h3>
            
            <el-row :gutter="20">
                <el-col :span="8">
                    <el-input
                        v-model="roomId"
                        placeholder="è¯·è¾“å…¥ç›´æ’­é—´ID"
                        prefix-icon="el-icon-video-camera"
                        :disabled="isRunning">
                    </el-input>
                </el-col>
                
                <el-col :span="6">
                    <el-slider
                        v-model="minConfidence"
                        :min="0.1"
                        :max="1.0"
                        :step="0.1"
                        show-input
                        :disabled="isRunning">
                    </el-slider>
                    <div style="text-align: center; margin-top: 5px; color: #666;">ç½®ä¿¡åº¦é˜ˆå€¼</div>
                </el-col>
                
                <el-col :span="6">
                    <el-slider
                        v-model="chunkDuration"
                        :min="0.5"
                        :max="3.0"
                        :step="0.5"
                        show-input
                        :disabled="isRunning">
                    </el-slider>
                    <div style="text-align: center; margin-top: 5px; color: #666;">éŸ³é¢‘å—æ—¶é•¿(ç§’)</div>
                </el-col>
                
                <el-col :span="4">
                    <el-button
                        v-if="!isRunning"
                        type="primary"
                        icon="el-icon-video-play"
                        @click="startTranscription"
                        :loading="loading"
                        style="width: 100%;">
                        å¼€å§‹è½¬å½•
                    </el-button>
                    <el-button
                        v-else
                        type="danger"
                        icon="el-icon-video-pause"
                        @click="stopTranscription"
                        :loading="loading"
                        style="width: 100%;">
                        åœæ­¢è½¬å½•
                    </el-button>
                </el-col>
            </el-row>
        </div>

        <!-- çŠ¶æ€é¢æ¿ -->
        <div class="status-panel">
            <h3 style="margin-bottom: 15px;">ğŸ“Š æœåŠ¡çŠ¶æ€</h3>
            
            <div>
                <span class="status-dot" :class="isRunning ? 'status-running' : 'status-stopped'"></span>
                <strong>è½¬å½•çŠ¶æ€: </strong>
                <span :style="{color: isRunning ? '#22c55e' : '#64748b'}">
                    {{ isRunning ? 'ğŸ¤ è¿è¡Œä¸­' : 'â¸ï¸ å·²åœæ­¢' }}
                </span>
            </div>
            
            <div v-if="currentSession">
                <strong>å½“å‰ä¼šè¯: </strong>{{ currentSession }}
            </div>
            
            <div v-if="currentRoom">
                <strong>ç›´æ’­é—´ID: </strong>{{ currentRoom }}
            </div>

            <!-- ç»Ÿè®¡ä¿¡æ¯ -->
            <div class="stats-grid" v-if="stats">
                <div class="stat-item">
                    <div class="stat-value">{{ stats.successful_transcriptions || 0 }}</div>
                    <div class="stat-label">æˆåŠŸè½¬å½•</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">{{ (stats.average_confidence || 0).toFixed(2) }}</div>
                    <div class="stat-label">å¹³å‡ç½®ä¿¡åº¦</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">{{ stats.total_audio_chunks || 0 }}</div>
                    <div class="stat-label">éŸ³é¢‘å—æ€»æ•°</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">{{ formatDuration(sessionDuration) }}</div>
                    <div class="stat-label">ä¼šè¯æ—¶é•¿</div>
                </div>
            </div>
        </div>

        <!-- è½¬å½•ç»“æœé¢æ¿ -->
        <div class="transcription-panel">
            <h3 style="margin-bottom: 15px;">ğŸ¯ å®æ—¶è½¬å½•ç»“æœ</h3>
            
            <div v-if="transcriptions.length === 0" style="text-align: center; color: #94a3b8; padding: 50px;">
                <i class="el-icon-microphone" style="font-size: 3em; margin-bottom: 15px;"></i>
                <p>ç­‰å¾…è¯­éŸ³è½¬å½•ç»“æœ...</p>
                <p style="font-size: 0.9em; margin-top: 5px;">ç‚¹å‡»"å¼€å§‹è½¬å½•"æŒ‰é’®å¼€å§‹è¯­éŸ³è¯†åˆ«</p>
            </div>
            
            <div v-for="(item, index) in transcriptions" :key="index" 
                 class="transcription-item"
                 :class="getConfidenceClass(item.confidence)">
                <div class="transcription-text">{{ item.text }}</div>
                <div class="transcription-meta">
                    ç½®ä¿¡åº¦: {{ (item.confidence * 100).toFixed(1) }}% | 
                    æ—¶é—´: {{ formatTime(item.timestamp) }} |
                    ç±»å‹: {{ item.is_final ? 'æœ€ç»ˆ' : 'ä¸´æ—¶' }}
                </div>
            </div>
        </div>
    </div>

    <script>
        new Vue({
            el: '#app',
            data() {
                return {
                    // æ§åˆ¶çŠ¶æ€
                    isRunning: false,
                    loading: false,
                    
                    // é…ç½®å‚æ•°
                    roomId: 'test_room_001',
                    minConfidence: 0.6,
                    chunkDuration: 1.0,
                    
                    // ä¼šè¯ä¿¡æ¯
                    currentSession: null,
                    currentRoom: null,
                    stats: null,
                    sessionStartTime: null,
                    
                    // è½¬å½•ç»“æœ
                    transcriptions: [],
                    
                    // WebSocketè¿æ¥
                    websocket: null,
                    
                    // å®šæ—¶å™¨
                    statusTimer: null
                }
            },
            
            computed: {
                sessionDuration() {
                    if (!this.sessionStartTime) return 0;
                    return Math.floor((Date.now() - this.sessionStartTime) / 1000);
                }
            },
            
            mounted() {
                this.initWebSocket();
                this.startStatusPolling();
            },
            
            beforeDestroy() {
                this.cleanup();
            },
            
            methods: {
                // åˆå§‹åŒ–WebSocketè¿æ¥
                initWebSocket() {
                    const wsUrl = `ws://localhost:8000/api/transcription/ws`;
                    this.websocket = new WebSocket(wsUrl);
                    
                    this.websocket.onopen = () => {
                        console.log('WebSocketè¿æ¥å·²å»ºç«‹');
                    };
                    
                    this.websocket.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.handleWebSocketMessage(data);
                    };
                    
                    this.websocket.onclose = () => {
                        console.log('WebSocketè¿æ¥å·²å…³é—­');
                        // å°è¯•é‡è¿
                        setTimeout(() => {
                            this.initWebSocket();
                        }, 3000);
                    };
                    
                    this.websocket.onerror = (error) => {
                        console.error('WebSocketé”™è¯¯:', error);
                    };
                },
                
                // å¤„ç†WebSocketæ¶ˆæ¯
                handleWebSocketMessage(data) {
                    if (data.type === 'transcription') {
                        this.addTranscription(data.data);
                    } else if (data.type === 'status') {
                        this.updateStatus(data.data);
                    }
                },
                
                // æ·»åŠ è½¬å½•ç»“æœ
                addTranscription(transcription) {
                    this.transcriptions.unshift({
                        text: transcription.text,
                        confidence: transcription.confidence,
                        timestamp: transcription.timestamp,
                        is_final: transcription.is_final
                    });
                    
                    // é™åˆ¶æ˜¾ç¤ºæ•°é‡
                    if (this.transcriptions.length > 50) {
                        this.transcriptions = this.transcriptions.slice(0, 50);
                    }
                },
                
                // å¼€å§‹è½¬å½•
                async startTranscription() {
                    if (!this.roomId.trim()) {
                        this.$message.warning('è¯·è¾“å…¥ç›´æ’­é—´ID');
                        return;
                    }
                    
                    this.loading = true;
                    
                    try {
                        const response = await fetch('/api/transcription/start', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                room_id: this.roomId,
                                chunk_duration: this.chunkDuration,
                                min_confidence: this.minConfidence,
                                save_audio: false
                            })
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            this.isRunning = true;
                            this.currentSession = result.data.session_id;
                            this.currentRoom = result.data.room_id;
                            this.sessionStartTime = Date.now();
                            this.transcriptions = [];
                            
                            this.$message.success('è½¬å½•æœåŠ¡å·²å¯åŠ¨');
                        } else {
                            this.$message.error('å¯åŠ¨å¤±è´¥: ' + result.message);
                        }
                    } catch (error) {
                        console.error('å¯åŠ¨è½¬å½•å¤±è´¥:', error);
                        this.$message.error('å¯åŠ¨å¤±è´¥: ' + error.message);
                    } finally {
                        this.loading = false;
                    }
                },
                
                // åœæ­¢è½¬å½•
                async stopTranscription() {
                    this.loading = true;
                    
                    try {
                        const response = await fetch('/api/transcription/stop', {
                            method: 'POST'
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            this.isRunning = false;
                            this.currentSession = null;
                            this.currentRoom = null;
                            this.sessionStartTime = null;
                            
                            this.$message.success('è½¬å½•æœåŠ¡å·²åœæ­¢');
                        } else {
                            this.$message.error('åœæ­¢å¤±è´¥: ' + result.message);
                        }
                    } catch (error) {
                        console.error('åœæ­¢è½¬å½•å¤±è´¥:', error);
                        this.$message.error('åœæ­¢å¤±è´¥: ' + error.message);
                    } finally {
                        this.loading = false;
                    }
                },
                
                // å®šæ—¶è·å–çŠ¶æ€
                startStatusPolling() {
                    this.statusTimer = setInterval(async () => {
                        try {
                            const response = await fetch('/api/transcription/status');
                            const status = await response.json();
                            this.updateStatus(status);
                        } catch (error) {
                            // é™é»˜å¤„ç†çŠ¶æ€è·å–é”™è¯¯
                        }
                    }, 2000);
                },
                
                // æ›´æ–°çŠ¶æ€
                updateStatus(status) {
                    this.isRunning = status.is_running;
                    this.currentSession = status.current_session_id;
                    this.currentRoom = status.current_room_id;
                    this.stats = status.stats;
                },
                
                // è·å–ç½®ä¿¡åº¦æ ·å¼ç±»
                getConfidenceClass(confidence) {
                    if (confidence >= 0.8) return 'confidence-high';
                    if (confidence >= 0.6) return 'confidence-medium';
                    return 'confidence-low';
                },
                
                // æ ¼å¼åŒ–æ—¶é—´
                formatTime(timestamp) {
                    return new Date(timestamp * 1000).toLocaleTimeString();
                },
                
                // æ ¼å¼åŒ–æ—¶é•¿
                formatDuration(seconds) {
                    const minutes = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    return `${minutes}:${secs.toString().padStart(2, '0')}`;
                },
                
                // æ¸…ç†èµ„æº
                cleanup() {
                    if (this.statusTimer) {
                        clearInterval(this.statusTimer);
                    }
                    if (this.websocket) {
                        this.websocket.close();
                    }
                }
            }
        });
    </script>
</body>
</html>